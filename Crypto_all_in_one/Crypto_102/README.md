
table_of_contens
================

### 1. RSA

---

**__chall.py__**

```py
e=3
n1=25204912957894049536633029588071532883154221495361435745558539407530325536509218257991893451902442183954212400671502526830623527340613723328379300388737939211263541814108106183164630301938900862986688763583982133846507136234797325243547177627054271161715200611591594812723672399437505379398941496184886411879923583394041753902383846644013849190900416111230521180435101859101110596828380586449182686175177638441549656137307050392520754146511496313215137339773851458160180450925216541537448515297981124184019831730808991821344392915274230294654187421183676471212265322367890189804699510021526923237231850244056681024361
n2=17730912385401458370516374144454354828481353051514329263921774569034415114147424203611660978860008058118764431105602401970281692066419254457694301039461623568501484102567802483628476717695013320444442267232019104240173401975387173805390636521671252624249730700497552226732834062715286458634274525026438931671208367178653031967364951679420066768732647183187381700016195545187024094717207787859217993871236368911145957298126589666514319408022801341248744002320245345234912423717815146532293315342644702101415345900126397475592837306256140915525455824350305349773210334856093169535686115299159772550674315375987529523179
n3=23693871552180460990138635073805949225912252125308334418081834697641804631104724668330415198785050388969117484647897131795893896100932121531733121069301557203541651575306855376180158639595396645851251320756224273151350168394783274111111375428683335001923152182758469432988805562827169898721409159172411067426322303967736140645806651181720610635139163613355013365367013643617931710120446074129630384181873406149243284193113399417540744056880787819360491511062694356302764642727497777585348003477373456680752873785829149551421840290660162776229985812994060664107888011786183808824620497078292008444842754064007647832261
c1=183043288861335204065865844573203046396558815444098608339644289867457892720011301899036695403473476413481715556140073941047117445884184973953125
c2=183043288861335204065865844573203046396558815444098608339644289867457892720011301899036695403473476413481715556140073941047117445884184973953125
c3=183043288861335204065865844573203046396558815444098608339644289867457892720011301899036695403473476413481715556140073941047117445884184973953125
```

#### 1. Tổng quan

+ Đây là một bài RSA cơ bản với $m ^ e = c \pmod{n}$ trong trường $n_1, n_2, n_3$ khác nhau với chung một `e` là 3

#### 2. Solution

+ Mình sử dụng crt rồi căn lại để lấy flag

#### 3. Code

```py
e=3
n1=25204912957894049536633029588071532883154221495361435745558539407530325536509218257991893451902442183954212400671502526830623527340613723328379300388737939211263541814108106183164630301938900862986688763583982133846507136234797325243547177627054271161715200611591594812723672399437505379398941496184886411879923583394041753902383846644013849190900416111230521180435101859101110596828380586449182686175177638441549656137307050392520754146511496313215137339773851458160180450925216541537448515297981124184019831730808991821344392915274230294654187421183676471212265322367890189804699510021526923237231850244056681024361
n2=17730912385401458370516374144454354828481353051514329263921774569034415114147424203611660978860008058118764431105602401970281692066419254457694301039461623568501484102567802483628476717695013320444442267232019104240173401975387173805390636521671252624249730700497552226732834062715286458634274525026438931671208367178653031967364951679420066768732647183187381700016195545187024094717207787859217993871236368911145957298126589666514319408022801341248744002320245345234912423717815146532293315342644702101415345900126397475592837306256140915525455824350305349773210334856093169535686115299159772550674315375987529523179
n3=23693871552180460990138635073805949225912252125308334418081834697641804631104724668330415198785050388969117484647897131795893896100932121531733121069301557203541651575306855376180158639595396645851251320756224273151350168394783274111111375428683335001923152182758469432988805562827169898721409159172411067426322303967736140645806651181720610635139163613355013365367013643617931710120446074129630384181873406149243284193113399417540744056880787819360491511062694356302764642727497777585348003477373456680752873785829149551421840290660162776229985812994060664107888011786183808824620497078292008444842754064007647832261
c1=183043288861335204065865844573203046396558815444098608339644289867457892720011301899036695403473476413481715556140073941047117445884184973953125
c2=183043288861335204065865844573203046396558815444098608339644289867457892720011301899036695403473476413481715556140073941047117445884184973953125
c3=183043288861335204065865844573203046396558815444098608339644289867457892720011301899036695403473476413481715556140073941047117445884184973953125
from gmpy2 import iroot
a = crt([c1, c2, c3], [n1, n2, n3])
m = int(iroot(int(a), e)[0])
print(bytes.fromhex(hex(m)[2:]))
```

### 2. Fishy

**__chall.py__**

```py
from hashlib import sha256
from random import SystemRandom
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from sage.all import *

n = 100
m = 100
q = 7
FF = GF(q)

def apply1(F, v):
    out = []
    for i in range(m):
        out.append((v.T * F[i] * v)[0, 0])
    return matrix(FF, out).T

def apply2(F, t, s):
    out = []
    for i in range(m):
        out.append((t.T * (F[i] + F[i].T) * s)[0, 0])
    return matrix(FF, out).T

def gen(v, s, F):
    output = []
    for _ in range(9):
        t = matrix(FF, [FF.random_element() for _ in range(n)]).T
        com = apply1(F, t)
        verif = apply2(F, t, s)
        a = sha256(bytes([int(i) for i in com.list() + v.list() + verif.list()])).digest()[0] % q
        output.append((com, t - a * s, verif))
    return output

def encrypt_flag(s):
    flag = b"flag{" + os.urandom(32) + b"}"
    key = sha256(str([int(i) for i in s.list()]).encode()).digest()
    cipher = AES.new(key, AES.MODE_CBC)
    ct = cipher.encrypt(pad(flag, 16))
    return ct, cipher.iv

rng = SystemRandom()

seed = [rng.randint(0, 255) for _ in range(64)]
gen_seed = bytes(seed)

F = []
for i in range(m):
    cur = []
    for j in range(n):
        cur.append([])
        for k in range(n):
            cur[-1].append(sha256(gen_seed).digest()[0] % q)
            gen_seed = sha256(gen_seed).digest()
    F.append(matrix(FF, n, n, cur))

s = random_matrix(FF, n, 1)	

v = apply1(F, s)
output = gen(v, s, F)

coms = [pi[0].list() for pi in output]
tass = [pi[1].list() for pi in output]
verifs = [pi[2].list() for pi in output]

ct, iv = encrypt_flag(s)

f = open("output.txt", "w")
f.write(f"{seed = }\n")
f.write(f"v = {[int(i) for i in v.list()]}\n")
f.write(f"{coms = }\n")
f.write(f"{tass = }\n")
f.write(f"{verifs = }\n")
f.write(f"{ct = }\n")
f.write(f"{iv = }")
f.close()
```

#### 1. Tổng quan

+ Bài này giống một bài giải cor mình đã từng viết. Do hàm encrpyt sử dụng `s` để làm key nên ta cần phải recover lại được `s` từ các dữ liệu đã được đề cho.
+ Do ta đã có seed nên ta hoàn toàn có thể tìm lại ma trận `F`

#### 2. Solution
+ Mình sẽ bỏ qua các hàm không quan trọng và nói thằng vào hàm `gen`

```py
def gen(v, s, F):
    output = []
    for _ in range(9):
        t = matrix(FF, [FF.random_element() for _ in range(n)]).T
        com = apply1(F, t)
        verif = apply2(F, t, s)
        a = sha256(bytes([int(i) for i in com.list() + v.list() + verif.list()])).digest()[0] % q
        output.append((com, t - a * s, verif))
    return output
```

Ta có output là kết quả của `com, t - a * s, verif` trong đó `a = sha256(bytes([int(i) for i in com.list() + v.list() + verif.list()])).digest()[0] % q` do nó được mod q nên a sẽ trong khoảng $a \in [0, q - 1]$. Mình khai thác lúc `a = 0` khi đó, `output.append((com, t , verif))` khiến kết quả output trả lại cho ta là `t` và `verif` mà `verif = apply2(F, t, s)` với hàm `apply2` như sau:

```py

def apply2(F, t, s):
    out = []
    for i in range(m):
        out.append((t.T * (F[i] + F[i].T) * s)[0, 0])
    return matrix(FF, out).
```

Mình có thể thấy đây làm hàm nhân vector `s` với một ma trận được tạo thành từ `t.T * (F[i] + F[i].T)`, nhưng ma trận này tuy có 100 hàng nhưn ta chỉ có `M.rank() == 99` nên ta chưa thể giải để tìm lạid dược s luôn được. Khi đó, mình sử dụng hàm right_kernel của sage để tính thêm phần `pad` nhằm 

$$
M * s + i * M * pad =  M . (s + i * pad) = output \pmod{p}
$$

khi đó ta cần tìm là `s + i * pad` và lấy đó để làm key giải mã flag.

#### 3. Code

```py

from hashlib import sha256
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from sage.all import *

def decrypt_flag(s, i, ct):
    key = sha256(str([int(i) for i in s.list()]).encode()).digest()
    cipher = AES.new(key, AES.MODE_CBC, iv = i)
    print(cipher.decrypt(ct))

def apply2(F, t):
    out = []
    for i in range(m):
        out.append((t.T * (F[i] + F[i].T)).list())
    return out

n = 100
m = 100
q = 7
FF = GF(q)

seed = [6, 80, 158, 13, 171, 216, 164, 5, 73, 233, 6, 213, 63, 162, 90, 63, 208, 245, 101, 11, 120, 95, 78, 145, 159, 108, 105, 252, 241, 124, 92, 120, 18, 177, 243, 237, 132, 103, 237, 11, 75, 141, 172, 208, 155, 47, 111, 59, 118, 209, 169, 81, 141, 236, 104, 131, 104, 194, 246, 232, 14, 246, 68, 172]
v = [3, 0, 2, 4, 6, 4, 4, 1, 0, 6, 4, 1, 6, 0, 1, 6, 4, 4, 4, 1, 0, 5, 4, 5, 6, 2, 5, 5, 1, 0, 2, 6, 3, 0, 3, 0, 0, 0, 2, 2, 2, 6, 4, 6, 6, 3, 2, 3, 1, 2, 3, 0, 6, 4, 3, 0, 0, 6, 2, 1, 1, 1, 3, 5, 5, 5, 0, 4, 1, 5, 2, 1, 3, 2, 1, 0, 6, 0, 6, 3, 3, 3, 5, 0, 4, 1, 0, 3, 3, 6, 1, 4, 4, 3, 6, 1, 1, 3, 3, 0]
coms = [[3, 1, 6, 1, 4, 6, 4, 1, 3, 5, 3, 1, 1, 6, 4, 0, 3, 5, 6, 3, 4, 4, 6, 4, 0, 1, 3, 5, 3, 0, 6, 1, 4, 3, 6, 6, 1, 2, 6, 2, 6, 4, 1, 4, 0, 5, 5, 3, 3, 5, 3, 1, 6, 0, 5, 1, 3, 6, 5, 3, 4, 5, 5, 4, 2, 3, 6, 4, 5, 5, 3, 4, 4, 0, 4, 3, 5, 1, 1, 6, 2, 5, 3, 5, 6, 6, 1, 3, 5, 2, 1, 1, 6, 5, 6, 4, 1, 5, 5, 0], [2, 3, 1, 0, 2, 3, 6, 2, 2, 6, 4, 0, 2, 6, 2, 5, 4, 0, 4, 1, 6, 4, 3, 4, 4, 1, 6, 3, 0, 0, 5, 0, 5, 5, 5, 5, 3, 3, 6, 3, 0, 4, 4, 2, 1, 0, 6, 0, 3, 0, 1, 1, 1, 3, 4, 4, 0, 3, 1, 5, 0, 0, 5, 0, 2, 2, 0, 5, 5, 2, 3, 4, 3, 6, 3, 3, 1, 0, 0, 3, 5, 6, 4, 2, 5, 0, 1, 5, 6, 1, 4, 2, 3, 0, 6, 5, 1, 5, 1, 4], [2, 4, 5, 4, 1, 1, 4, 5, 5, 4, 3, 1, 4, 3, 2, 3, 2, 4, 4, 2, 3, 0, 4, 1, 0, 6, 1, 6, 2, 6, 6, 3, 4, 0, 6, 3, 0, 0, 6, 3, 4, 4, 2, 4, 0, 5, 1, 4, 4, 6, 6, 3, 1, 0, 3, 0, 0, 1, 5, 0, 6, 0, 1, 3, 4, 0, 2, 6, 1, 0, 4, 1, 2, 3, 0, 2, 0, 3, 0, 2, 4, 6, 1, 6, 0, 1, 5, 5, 3, 3, 0, 4, 1, 6, 2, 4, 1, 4, 4, 0], [3, 5, 5, 0, 6, 0, 0, 5, 0, 6, 6, 0, 6, 0, 6, 3, 3, 4, 1, 3, 5, 2, 3, 6, 1, 0, 3, 5, 4, 3, 0, 5, 1, 2, 4, 0, 3, 4, 0, 0, 6, 0, 1, 5, 1, 5, 4, 1, 6, 6, 0, 4, 6, 1, 4, 2, 2, 4, 0, 1, 1, 1, 3, 5, 2, 5, 4, 4, 4, 3, 0, 2, 3, 5, 4, 5, 4, 6, 0, 2, 1, 2, 2, 6, 6, 5, 1, 0, 3, 0, 3, 3, 1, 1, 2, 5, 2, 4, 6, 0], [2, 6, 5, 6, 1, 6, 3, 4, 6, 1, 2, 5, 2, 3, 1, 1, 3, 4, 6, 5, 2, 4, 0, 0, 0, 1, 3, 2, 6, 5, 5, 1, 2, 6, 0, 3, 2, 1, 4, 0, 5, 3, 4, 6, 3, 1, 5, 5, 6, 6, 3, 0, 0, 5, 3, 3, 4, 4, 5, 1, 1, 0, 5, 6, 2, 6, 3, 0, 5, 2, 3, 2, 4, 3, 4, 4, 3, 3, 2, 4, 6, 0, 6, 5, 6, 1, 2, 3, 5, 1, 5, 3, 4, 6, 3, 6, 3, 1, 2, 6], [2, 0, 1, 2, 6, 0, 5, 6, 6, 3, 2, 6, 1, 1, 6, 5, 2, 4, 4, 2, 2, 2, 0, 6, 1, 5, 1, 1, 1, 6, 6, 5, 4, 3, 4, 5, 4, 0, 0, 4, 4, 4, 1, 0, 2, 0, 4, 5, 6, 5, 4, 2, 1, 0, 0, 4, 1, 4, 3, 6, 6, 1, 0, 5, 3, 4, 0, 5, 6, 6, 2, 4, 3, 3, 6, 6, 1, 3, 4, 3, 1, 4, 4, 5, 5, 3, 6, 5, 2, 3, 1, 2, 4, 5, 6, 3, 5, 4, 6, 3], [3, 0, 1, 4, 0, 4, 5, 3, 4, 2, 4, 6, 0, 2, 1, 5, 4, 1, 5, 3, 0, 2, 2, 0, 0, 4, 3, 2, 3, 5, 6, 0, 6, 3, 1, 4, 2, 6, 5, 0, 6, 3, 3, 2, 2, 4, 1, 3, 4, 0, 2, 5, 1, 0, 5, 1, 2, 5, 2, 3, 4, 4, 0, 0, 1, 4, 0, 1, 2, 2, 5, 2, 5, 0, 3, 4, 2, 6, 4, 5, 0, 2, 0, 6, 1, 4, 2, 2, 3, 3, 2, 4, 0, 1, 0, 2, 1, 2, 5, 3], [2, 1, 1, 6, 5, 2, 4, 6, 6, 5, 2, 3, 1, 5, 4, 2, 1, 4, 6, 1, 6, 4, 0, 2, 4, 5, 5, 2, 1, 6, 0, 6, 3, 3, 5, 5, 4, 3, 6, 2, 2, 5, 3, 4, 0, 1, 4, 4, 5, 3, 3, 1, 3, 5, 0, 4, 5, 3, 1, 6, 2, 6, 2, 3, 4, 4, 2, 6, 5, 1, 6, 0, 0, 5, 6, 6, 4, 4, 3, 4, 5, 4, 5, 5, 6, 0, 2, 0, 6, 1, 5, 5, 5, 5, 4, 4, 3, 1, 1, 6], [5, 4, 6, 1, 3, 2, 3, 3, 6, 4, 4, 4, 6, 2, 3, 0, 1, 3, 0, 4, 0, 2, 4, 6, 4, 0, 1, 3, 5, 3, 4, 0, 4, 4, 0, 1, 2, 5, 3, 3, 4, 3, 5, 6, 5, 2, 4, 5, 2, 3, 3, 3, 3, 2, 3, 3, 3, 1, 2, 0, 4, 2, 0, 6, 5, 1, 4, 2, 5, 4, 0, 3, 1, 2, 1, 4, 6, 0, 1, 4, 5, 3, 5, 6, 4, 6, 6, 6, 1, 4, 6, 1, 5, 6, 3, 3, 3, 0, 1, 2]]
tass = [[1, 4, 0, 6, 1, 2, 1, 3, 5, 5, 1, 1, 6, 4, 3, 5, 5, 3, 3, 2, 4, 6, 1, 3, 0, 1, 2, 5, 4, 4, 5, 4, 2, 3, 0, 6, 1, 3, 1, 4, 1, 3, 6, 6, 6, 2, 2, 3, 2, 3, 1, 2, 6, 3, 5, 1, 5, 4, 0, 0, 4, 2, 2, 4, 1, 5, 5, 2, 1, 5, 5, 2, 1, 1, 0, 5, 6, 2, 6, 4, 3, 2, 5, 5, 0, 6, 0, 6, 5, 0, 0, 4, 6, 0, 3, 0, 5, 5, 4, 0], [4, 4, 6, 5, 0, 3, 4, 4, 4, 2, 0, 1, 0, 5, 6, 2, 5, 4, 0, 2, 4, 6, 5, 1, 1, 2, 6, 1, 2, 3, 5, 3, 0, 3, 4, 1, 3, 3, 1, 6, 2, 3, 4, 2, 2, 2, 3, 0, 4, 6, 3, 1, 6, 0, 0, 6, 1, 4, 3, 4, 3, 2, 6, 0, 3, 4, 1, 2, 4, 4, 0, 5, 1, 1, 0, 0, 5, 1, 1, 1, 1, 2, 3, 1, 5, 4, 1, 0, 0, 3, 2, 3, 0, 4, 5, 6, 0, 6, 1, 0], [1, 1, 4, 5, 2, 1, 4, 6, 5, 1, 3, 1, 5, 4, 6, 3, 0, 6, 1, 6, 5, 0, 4, 6, 1, 6, 5, 5, 6, 1, 0, 5, 6, 6, 6, 3, 0, 0, 1, 5, 0, 6, 1, 5, 4, 5, 1, 5, 5, 2, 4, 3, 1, 0, 5, 0, 6, 3, 6, 6, 6, 1, 0, 1, 5, 1, 5, 4, 1, 6, 5, 6, 2, 0, 6, 5, 5, 2, 1, 3, 0, 4, 2, 1, 5, 6, 5, 3, 3, 1, 2, 3, 3, 5, 0, 3, 3, 2, 5, 2], [6, 0, 1, 1, 4, 5, 1, 5, 2, 1, 5, 0, 0, 5, 4, 0, 2, 5, 1, 2, 3, 6, 2, 4, 3, 4, 1, 4, 4, 2, 2, 2, 3, 1, 4, 0, 1, 5, 0, 2, 4, 2, 3, 4, 4, 6, 6, 1, 3, 4, 6, 2, 6, 3, 6, 5, 2, 1, 3, 3, 3, 4, 6, 0, 5, 6, 6, 2, 4, 5, 3, 5, 6, 2, 2, 5, 2, 1, 4, 6, 5, 1, 6, 4, 5, 5, 6, 0, 6, 2, 1, 5, 0, 0, 4, 4, 6, 0, 0, 5], [4, 0, 0, 0, 6, 0, 2, 1, 1, 0, 4, 5, 2, 4, 3, 2, 1, 6, 0, 6, 4, 5, 3, 1, 1, 4, 0, 5, 4, 4, 6, 4, 1, 1, 6, 3, 0, 4, 4, 2, 6, 0, 2, 3, 4, 6, 0, 3, 0, 3, 5, 2, 2, 2, 4, 4, 1, 2, 1, 1, 0, 2, 5, 4, 2, 3, 0, 0, 6, 1, 5, 5, 5, 3, 5, 4, 6, 2, 2, 0, 4, 3, 1, 3, 3, 5, 4, 0, 5, 6, 3, 3, 3, 5, 4, 6, 1, 4, 0, 2], [1, 6, 1, 0, 0, 2, 4, 0, 0, 1, 1, 0, 2, 3, 4, 5, 5, 0, 1, 5, 2, 4, 6, 6, 3, 5, 1, 6, 2, 1, 6, 4, 5, 0, 4, 0, 5, 0, 5, 4, 6, 3, 6, 0, 6, 0, 2, 6, 1, 1, 6, 4, 2, 6, 1, 4, 6, 0, 0, 2, 1, 3, 2, 1, 5, 1, 5, 3, 6, 2, 5, 1, 1, 3, 6, 5, 4, 1, 2, 5, 3, 4, 3, 6, 2, 2, 0, 4, 4, 5, 3, 2, 1, 6, 1, 3, 0, 0, 1, 2], [3, 0, 0, 6, 3, 3, 0, 1, 1, 4, 4, 4, 0, 1, 4, 6, 5, 4, 3, 3, 0, 5, 1, 2, 1, 5, 5, 3, 0, 0, 0, 6, 1, 2, 0, 3, 1, 4, 3, 3, 3, 3, 5, 5, 2, 2, 6, 4, 4, 0, 5, 6, 2, 2, 1, 0, 5, 4, 0, 1, 2, 2, 2, 6, 6, 6, 0, 4, 1, 6, 1, 5, 6, 3, 4, 6, 4, 2, 1, 5, 5, 6, 3, 6, 5, 3, 5, 2, 6, 5, 3, 2, 2, 2, 3, 2, 2, 2, 3, 1], [6, 0, 4, 6, 1, 6, 4, 1, 6, 4, 0, 1, 6, 5, 4, 3, 5, 6, 4, 5, 5, 5, 5, 4, 2, 0, 6, 6, 6, 5, 4, 3, 5, 1, 6, 6, 1, 4, 1, 4, 4, 2, 2, 1, 3, 6, 3, 2, 5, 1, 1, 2, 2, 0, 3, 1, 3, 6, 3, 1, 4, 0, 5, 5, 3, 3, 3, 2, 6, 0, 5, 0, 3, 1, 2, 6, 3, 5, 2, 4, 2, 1, 2, 2, 4, 1, 5, 4, 0, 2, 3, 0, 2, 0, 5, 4, 2, 4, 6, 1], [6, 6, 1, 5, 0, 4, 0, 3, 2, 5, 1, 0, 3, 3, 5, 1, 1, 1, 3, 3, 1, 4, 5, 4, 1, 2, 5, 5, 0, 5, 5, 0, 0, 4, 4, 5, 5, 5, 1, 0, 4, 0, 5, 6, 2, 5, 3, 5, 0, 2, 1, 4, 0, 1, 5, 2, 1, 0, 3, 0, 5, 6, 6, 2, 5, 3, 3, 3, 3, 1, 5, 4, 4, 3, 6, 3, 3, 6, 1, 6, 5, 4, 0, 5, 5, 4, 0, 0, 3, 4, 0, 1, 1, 4, 4, 1, 4, 2, 3, 0]]
verifs = [[3, 4, 6, 6, 2, 0, 2, 1, 4, 0, 5, 4, 1, 2, 4, 0, 3, 4, 3, 5, 6, 4, 3, 3, 4, 2, 0, 1, 4, 3, 6, 1, 2, 6, 5, 4, 3, 4, 3, 0, 4, 2, 0, 4, 1, 1, 3, 3, 1, 4, 2, 3, 6, 4, 3, 0, 0, 1, 5, 0, 0, 1, 1, 5, 5, 4, 4, 0, 4, 6, 4, 1, 1, 5, 5, 1, 1, 0, 2, 3, 4, 1, 6, 0, 4, 6, 5, 5, 5, 1, 6, 0, 1, 6, 2, 2, 0, 6, 3, 4], [0, 3, 4, 1, 1, 0, 2, 5, 5, 3, 2, 2, 2, 2, 3, 4, 5, 0, 0, 6, 6, 1, 2, 4, 2, 2, 5, 2, 0, 2, 5, 2, 4, 6, 3, 3, 4, 2, 0, 3, 2, 5, 1, 6, 1, 0, 3, 3, 5, 5, 6, 2, 1, 5, 5, 1, 4, 3, 5, 1, 6, 4, 4, 5, 0, 6, 1, 1, 1, 0, 5, 4, 6, 3, 5, 1, 6, 0, 6, 5, 2, 0, 0, 2, 0, 1, 3, 4, 3, 6, 4, 6, 3, 3, 5, 5, 6, 2, 1, 3], [3, 1, 3, 5, 4, 0, 6, 5, 3, 6, 5, 1, 1, 4, 5, 3, 2, 1, 4, 5, 2, 4, 3, 5, 3, 5, 5, 0, 5, 0, 3, 1, 4, 3, 1, 4, 3, 1, 1, 6, 3, 5, 6, 5, 4, 5, 4, 5, 3, 0, 4, 5, 2, 6, 5, 0, 5, 3, 2, 6, 3, 6, 3, 6, 4, 2, 0, 1, 2, 6, 5, 3, 6, 2, 3, 1, 6, 4, 6, 2, 1, 3, 3, 6, 4, 1, 2, 2, 6, 2, 3, 0, 0, 4, 2, 1, 5, 1, 3, 4], [4, 0, 4, 4, 0, 6, 6, 5, 2, 6, 5, 1, 0, 5, 3, 3, 1, 6, 5, 2, 5, 0, 6, 6, 6, 1, 5, 3, 5, 5, 0, 2, 4, 1, 5, 0, 4, 0, 5, 0, 6, 5, 3, 0, 1, 5, 2, 1, 6, 2, 3, 4, 4, 6, 5, 1, 0, 1, 0, 2, 6, 5, 4, 4, 1, 1, 6, 2, 5, 0, 5, 2, 6, 4, 3, 0, 4, 2, 4, 3, 2, 6, 1, 6, 5, 5, 4, 2, 2, 6, 6, 6, 2, 2, 0, 5, 1, 6, 6, 0], [1, 6, 1, 6, 0, 0, 4, 6, 0, 0, 1, 5, 2, 0, 3, 1, 2, 1, 1, 0, 5, 1, 0, 6, 5, 6, 1, 0, 2, 0, 3, 3, 1, 2, 3, 6, 6, 6, 2, 0, 6, 3, 1, 6, 6, 3, 4, 1, 2, 0, 5, 1, 6, 1, 2, 2, 2, 6, 0, 4, 4, 1, 2, 1, 0, 4, 5, 6, 1, 5, 4, 6, 5, 2, 3, 0, 2, 1, 3, 6, 2, 0, 3, 5, 6, 1, 6, 1, 2, 3, 4, 6, 3, 6, 0, 6, 6, 0, 5, 6], [6, 5, 4, 2, 5, 6, 5, 6, 1, 4, 2, 0, 6, 1, 6, 5, 3, 6, 1, 6, 1, 2, 3, 0, 0, 5, 5, 1, 6, 1, 1, 0, 2, 1, 3, 5, 5, 1, 0, 0, 5, 5, 0, 6, 6, 4, 3, 5, 3, 3, 1, 1, 6, 4, 1, 6, 1, 1, 6, 6, 3, 3, 0, 4, 3, 5, 5, 4, 5, 5, 3, 5, 2, 5, 5, 5, 4, 6, 2, 3, 3, 1, 1, 6, 4, 6, 0, 5, 6, 0, 6, 3, 6, 4, 0, 0, 2, 2, 1, 2], [3, 5, 5, 1, 5, 1, 4, 2, 0, 2, 3, 2, 6, 0, 2, 2, 5, 6, 2, 0, 0, 6, 5, 3, 4, 2, 4, 2, 4, 3, 1, 0, 6, 0, 5, 2, 1, 1, 3, 3, 5, 4, 5, 6, 6, 2, 4, 1, 1, 2, 4, 5, 2, 3, 4, 2, 3, 5, 1, 6, 6, 4, 4, 3, 4, 0, 1, 5, 0, 1, 0, 6, 2, 1, 1, 3, 4, 1, 4, 3, 5, 6, 3, 0, 5, 0, 3, 3, 3, 3, 4, 4, 5, 5, 0, 0, 6, 2, 1, 6], [6, 2, 3, 0, 3, 3, 3, 0, 5, 3, 1, 5, 0, 2, 3, 0, 2, 2, 5, 5, 6, 5, 1, 3, 4, 2, 0, 2, 3, 4, 1, 0, 3, 2, 4, 5, 3, 4, 2, 6, 6, 1, 2, 4, 5, 3, 1, 4, 3, 4, 5, 1, 3, 4, 5, 1, 1, 6, 6, 1, 0, 1, 5, 3, 3, 4, 5, 4, 0, 5, 6, 4, 4, 0, 2, 5, 5, 2, 1, 4, 6, 3, 3, 3, 2, 5, 1, 6, 5, 3, 1, 4, 6, 3, 1, 2, 5, 1, 5, 1], [6, 1, 5, 3, 2, 3, 5, 3, 5, 2, 1, 0, 1, 2, 2, 4, 4, 1, 6, 2, 5, 0, 6, 4, 6, 5, 6, 0, 6, 5, 4, 4, 5, 4, 3, 1, 1, 1, 0, 2, 3, 0, 6, 2, 4, 0, 6, 1, 6, 5, 5, 2, 6, 3, 4, 2, 5, 0, 5, 5, 5, 0, 6, 3, 3, 2, 5, 1, 1, 4, 4, 1, 5, 1, 6, 0, 5, 3, 6, 4, 2, 1, 0, 0, 4, 2, 3, 5, 3, 5, 1, 3, 5, 3, 5, 6, 4, 0, 0, 4]]
ct = b'\xf7\xfd\thn\xc0="\xed\x15\xa4\x9e\xba\x18k\xf1\x92\xb2~\x14\xcc\n\xc1\xb2\xa4F\x13\x89\xaa</!7\xb5\x03Z\xcd6\xbd\x12\x04\xf6\xd7\x84\xbb0\x14f'
iv = b'l"\xf8uy\xeai\xc2@\xc4\xdbPo\x16w\x0e'

gen_seed = bytes(seed)

F = []
for i in range(m):
    cur = []
    for j in range(n):
        cur.append([])
        for k in range(n):
            cur[-1].append(sha256(gen_seed).digest()[0] % q)
            gen_seed = sha256(gen_seed).digest()
    F.append(matrix(FF, n, n, cur))
    
for _ in range(9):
    
    com = coms[_]
    verif = verifs[_]
    a = sha256(bytes([int(i) for i in com + v + verif])).digest()[0] % q
    
    if a == 0:
        t = column_matrix(tass[_])
        com = column_matrix(com)
        verif = column_matrix(FF, verif)
        v = column_matrix(v)
        M = matrix(FF, apply2(F, t))
        pad = M.right_kernel_matrix()[0]
        s = M.solve_right(verif)
        for i in range(q):
            decrypt_flag(vector(s) + i * vector(pad), iv, ct)
        exit()
```

### 3. chal1

**__chall.py__**

```py

from Crypto.Util.number import *
import random
import os

e = 65537
p = getPrime(1024)
while (p - 1) % e == 0:
    p = getPrime(1024)

Ns = []
while len(Ns) < 4:
    q = getPrime(2048)
    N = p * q
    if (q - 1) % e != 0 and N not in Ns:
        Ns.append(N)

flag = b'crypto{gasfasfsa}'
flag += os.urandom(3072 // 8 - 2 - len(flag))
flag = bytes_to_long(flag)

cts = [pow(flag, e, N) for N in Ns]
Ns = [N + int(os.urandom(32).hex(), 16) for N in Ns]
random.shuffle(Ns)

f = open("output.txt", "w")
f.write(f"{Ns = }\n")
f.write(f"{cts = }\n")
f.close()
```

#### 1. Tổng quan

+ Mình có 4 cái cipher text của `m` được mã hóa bởi 4 `n` khác nhau. Không những vây, các `n` còn bị cộng thêm 1 phần hệ số nhỏ nữa khiến cho các số `n` ta nhận được không còn chính xác.
+ Ngoài ra các n của ta đều có điểm chung 

```py
Ns = []
while len(Ns) < 4:
    q = getPrime(2048)
    N = p * q
    if (q - 1) % e != 0 and N not in Ns:
        Ns.append(N)
```
nên nếu ta tìm được `n` thì ta hoàn toàn có thể dễ dàng tìm được flag nên bài này điểm mấu chốt trở thành tìm lại public key đúng cho mỗi cipher text.

#### 2. Solution

+ Ta có 

$$

N^{-}_{1} = N_1 + pad_1 = p * q_1 + pad_1 \\
N^{-}_{2} = N_2 + pad_2 = p * q_2 + pad_2 \\
N^{-}_{3} = N_3 + pad_3 = p * q_3 + pad_3 \\
N^{-}_{4} = N_4 + pad_4 = p * q_4 + pad_4 \\

$$

Vậy bài toán ta có thể đưa về gcd xấp xỉ (agcd) khi đó agcd($N ^ {-}_{1}, N ^ {-}_{2}, N ^ {-}_{3}, N ^ {-}_{4}$) = p. Khi có p thì ta có thể tìm lại $q = N ^ {-}_{1} / p$ do phần pad rất nhỏ so với các chỉ số khác. Và từ đó ta có thể dễ dàng có flag.

+ Còn về thuật toán agcd mình có viết ở một bài viết trước nên có thể thể xem lại nếu chưa rõ.

#### 3. Code

```py

from Crypto.Util.number import long_to_bytes

def matrix_overview(BB):
    for ii in range(BB.dimensions()[0]):
        a = ('%02d ' % ii)
        for jj in range(BB.dimensions()[1]):
            if BB[ii, jj] == 0:
                a += ' '
            else:
                a += 'X'
            if BB.dimensions()[0] < 60:
                a += ' '
        print(a)
from itertools import permutations

Ns = [2130976337586005237156464206440420238795565461269490301585855909243137947798414127770622674742724352434331955896863644115665473805181972333821798148318799414303412313764438520452979811024935800578317205194535118744206321140383615692221976332951446168327815156707303807757477643618478178097808590013870602530571978483874107959618249495480404703039921462919059600508942634416478729156246889530274312285677320148095767520776395382610426929918977563944737154815051073804770658613252320954771991606103098402264525379694922957368418168481371020472830737481531266630093221880319725471683836854133653864083162346785113297683705360085961158753163727611496209455438221912781269299711779832658189935673806833012531569328477760118728288998405856941007991900725659274293982786073642879717420962731703476868833118161112664313792413800564596946051574011354351831603624300154840811613782989056951172522500835314687914163366650332659633288163, 2724037318674271086650447702070622375034861255304438717212172859171502986139415815041303457248662898812636029870181169539698582157596678976319885943602013615596314541242314223796153426926255235152668722870474200290619913816825637578268245306697316483895912232417073776730330891849576569682680319366880421269826884414700000757784798502289304103210140185862955753436603722506089178809949852990108336262759717632367946203946246293777315895381895311165687091955990889229787046729823535584170695122315779869883592318911535794642950406414658398131464828814786912910452684500515681764429615217619353314875027749599080323389716386057532469740854693102887806019415096201152871365561547406714917294252954637321114547657092913684836104437438009065254935303766017775862067651265645828848328151185935792297944544632491664122092606459921464368198588017057047648122587163017214781076851088421955611649541557810984363440551831480883100894756, 3383691878575471137089480888231172217866372258737361724957049521443443763029492809957409855991601293006223529553883773627262495918396580897315269393280090785607968778675228571143800897710500032700970973479956266461645024228597797295405062451269007563713263628196000287257749403776819070878113025521171955244378522212336359386213357451545050706081701069044868262458018932816656573810080433013346290226230600368695800792576148525630013674812581362450498826742727103970523587676787319516950204652226049894689926060531804700811668476231071908657043230214206125790484400070750115887590529367278059485685813618860125616508009373173700272979627354838587983949365228826137095388053111649098562302326183354472597204968565593722161991837351387615485549721520279021350590308413210999753314846116160847470647157455724360861290543130383536365633765271408624374535169271534024038682821784256903999466933064864745320489800372659636332745046, 3332851029830030020505312984858653864345835268092239580990493634816507465430956556762570304817073168605608529751959654545598713625624868535189519475633800845574486091187281279194464271600451330990793201223344729337160440769167384107356313334614380612681788939375289389552144092580754111812673799210293171571982790813487441850940616422874478885343212354265965733309928658793814208027091847421067475414218368539114727554252047972983373810874608325994896019236467640264187075166139858244443447044173305977034944223075961886821726913126402563633247855133971551147199604314569161069733929079286010685677153823781994220227408147047766849481286415120189298226090927049839969843135486078365496550479979529714310517104538163512763611247082326619524794973225502128429325265447729855527054260487797674749859721550631596291203249557847087262131821860919842254911909880721230913107733946362614921747812086494067811669012763198977877196090]
cts = [2920799356879250173447111776038849181098558087641816048276631516536993523688193882092723029394546779536095873224544585725343156520463117216509685723490837241788574056945457366746185782643192664508237067226182087617606922537076464379133415387617426663206748930129120915798950639705647090473111761353381273404261455424208890011694857621299074960837146049595989606332923828202391960344832094705857766885009460934356064579109718550008690634313743379177775192620804868609023704893202702912741883629599893521811884276941254734185373234781643402532721762824003010414264945053079309315313865134962984195976009130323486788964038228855989435947696966520440141881382228773099941354795667168696081093318535589931321297264982050645689991199266432933470181417203529616360597081020312451026614640803827775464538418865077879521754960625334043261141672384390722420825219108230411712055121935009223994581765203572536902273404299758455675439716, 283216691602083334005246638968097857275267182294137317946325320359123795402430057506720593818727474662215098329510647142743643046436685426552528303484369356060407286254097580835495484150137250253871785207943571863397430360490243515230128774584253289192899011248527340887737629761871089668382770396310606432582053901293299931822613593989274141244630173519376210793660273216088694636414125888456705896597034509313899057277107826790904466879762376556518540280095501421291226002138895857852530608767139681322733544708974607912631493011084548500839002454904505608611532002954434523431696045222506719263349729636693599700448447286366487016240653311773413719301479555195204721651263835365753283741191961306000271550958386765572111800785813811467614971291858380424207212470984391167760694805331930671076508836978834832661887925799776640390840470977875974323060557817792235965552255885276226057560230583826658034583575801554695059047, 268979405122804393027170445530338446206610074742832867718235870457475626024942680826027972068483238903246745764920875307179316418909178761558070465939341662641793197823095292334590592800021790441975896979146907263444313097546935175608594332475985436351896079585299623851919343338824266834209570792007094916396719215272148044469796689662013572640280148250625383108400184325618687803818355414450557575712792024247281478742164458095028155116210812552094668489765384790292604864975666989160165230770573449907091076407504614433265625180391580977483917983831858464922447770185414815446860865289281855742507304882746806308667258925044364467364740363097016993746642009182837176837819962230359591693139409031241687572877844627566755145072816229129417335557343315356662961165699996512043446852934695488341048967406782608764841478879940658782647794264034547319866199830285283932601838086989657960652975690033258066348895790073241794014, 1521158362715155454097756931052727717878889869688712453486606517629270329777684406452036981546430242564656146926258714199957602504207629834143865996729006122009889382535315498401491725307558088861688867142674873316236088299621053183453269904865862625765686025696069252520191342674399759900363487828527390473331876374877066463173271550524728008041915614246144806074264715708703233530474446610975016681526269110640669256441069042633622793941942259576439672237348714735168439068342911261074945918185355498255850927504972534036307621100571535263476170038941793883514864519982892473549754232231586079824086768168302432512297722672301238996302640516015249179302849667304288360560228729309230540380560519733720817984973175451050660458649685273186719284955088708283941197117266321098232994179275405962963082204615237311233943307292001768528015035597262519767340674366161929437638853140199198272216964710062026811799480052533506554371]
e = 65537

alpha = 8 * 32

n = Ns[0]

M = block_matrix([
    [matrix([[2 ** (alpha + 1)]]), column_matrix(Ns[1:]).T],
    [0, diagonal_matrix([-n]* (len(Ns) - 1)) ]
])

q = int(abs(M.LLL()[0][0] // (2 ** (alpha + 1))))
p = n // q
for ct in cts:
	m = pow(ct, pow(e, -1, (p - 1) * (q - 1)), p * q)
	if b'ASCIS' in long_to_bytes(m):
		print(long_to_bytes(m))
		break
```

#### 4. Another way

+ Mình có thể thấy như sau:

$$

m ^ e = c_1 \pmod{n_1} \to m ^ e = c_1 + k_1 * p \\
m ^ e = c_2 \pmod{n_1} \to m ^ e = c_2 + k_2 * p \\
m ^ e = c_3 \pmod{n_1} \to m ^ e = c_3 + k_3 * p \\
m ^ e = c_4 \pmod{n_1} \to m ^ e = c_4 + k_4 * p \\

\to c_1 - c_2 = k * p \\
\to c_3 - c_3 = k * p \\

\to gcd(c_1 - c_2, c_3 - c_4) = p
$$

+ Từ đó mình có thể hoàn thành chall một cách dễ dàng.

```py

from Crypto.Util.number import *

Ns = [2130976337586005237156464206440420238795565461269490301585855909243137947798414127770622674742724352434331955896863644115665473805181972333821798148318799414303412313764438520452979811024935800578317205194535118744206321140383615692221976332951446168327815156707303807757477643618478178097808590013870602530571978483874107959618249495480404703039921462919059600508942634416478729156246889530274312285677320148095767520776395382610426929918977563944737154815051073804770658613252320954771991606103098402264525379694922957368418168481371020472830737481531266630093221880319725471683836854133653864083162346785113297683705360085961158753163727611496209455438221912781269299711779832658189935673806833012531569328477760118728288998405856941007991900725659274293982786073642879717420962731703476868833118161112664313792413800564596946051574011354351831603624300154840811613782989056951172522500835314687914163366650332659633288163, 2724037318674271086650447702070622375034861255304438717212172859171502986139415815041303457248662898812636029870181169539698582157596678976319885943602013615596314541242314223796153426926255235152668722870474200290619913816825637578268245306697316483895912232417073776730330891849576569682680319366880421269826884414700000757784798502289304103210140185862955753436603722506089178809949852990108336262759717632367946203946246293777315895381895311165687091955990889229787046729823535584170695122315779869883592318911535794642950406414658398131464828814786912910452684500515681764429615217619353314875027749599080323389716386057532469740854693102887806019415096201152871365561547406714917294252954637321114547657092913684836104437438009065254935303766017775862067651265645828848328151185935792297944544632491664122092606459921464368198588017057047648122587163017214781076851088421955611649541557810984363440551831480883100894756, 3383691878575471137089480888231172217866372258737361724957049521443443763029492809957409855991601293006223529553883773627262495918396580897315269393280090785607968778675228571143800897710500032700970973479956266461645024228597797295405062451269007563713263628196000287257749403776819070878113025521171955244378522212336359386213357451545050706081701069044868262458018932816656573810080433013346290226230600368695800792576148525630013674812581362450498826742727103970523587676787319516950204652226049894689926060531804700811668476231071908657043230214206125790484400070750115887590529367278059485685813618860125616508009373173700272979627354838587983949365228826137095388053111649098562302326183354472597204968565593722161991837351387615485549721520279021350590308413210999753314846116160847470647157455724360861290543130383536365633765271408624374535169271534024038682821784256903999466933064864745320489800372659636332745046, 3332851029830030020505312984858653864345835268092239580990493634816507465430956556762570304817073168605608529751959654545598713625624868535189519475633800845574486091187281279194464271600451330990793201223344729337160440769167384107356313334614380612681788939375289389552144092580754111812673799210293171571982790813487441850940616422874478885343212354265965733309928658793814208027091847421067475414218368539114727554252047972983373810874608325994896019236467640264187075166139858244443447044173305977034944223075961886821726913126402563633247855133971551147199604314569161069733929079286010685677153823781994220227408147047766849481286415120189298226090927049839969843135486078365496550479979529714310517104538163512763611247082326619524794973225502128429325265447729855527054260487797674749859721550631596291203249557847087262131821860919842254911909880721230913107733946362614921747812086494067811669012763198977877196090]
cts = [2920799356879250173447111776038849181098558087641816048276631516536993523688193882092723029394546779536095873224544585725343156520463117216509685723490837241788574056945457366746185782643192664508237067226182087617606922537076464379133415387617426663206748930129120915798950639705647090473111761353381273404261455424208890011694857621299074960837146049595989606332923828202391960344832094705857766885009460934356064579109718550008690634313743379177775192620804868609023704893202702912741883629599893521811884276941254734185373234781643402532721762824003010414264945053079309315313865134962984195976009130323486788964038228855989435947696966520440141881382228773099941354795667168696081093318535589931321297264982050645689991199266432933470181417203529616360597081020312451026614640803827775464538418865077879521754960625334043261141672384390722420825219108230411712055121935009223994581765203572536902273404299758455675439716, 283216691602083334005246638968097857275267182294137317946325320359123795402430057506720593818727474662215098329510647142743643046436685426552528303484369356060407286254097580835495484150137250253871785207943571863397430360490243515230128774584253289192899011248527340887737629761871089668382770396310606432582053901293299931822613593989274141244630173519376210793660273216088694636414125888456705896597034509313899057277107826790904466879762376556518540280095501421291226002138895857852530608767139681322733544708974607912631493011084548500839002454904505608611532002954434523431696045222506719263349729636693599700448447286366487016240653311773413719301479555195204721651263835365753283741191961306000271550958386765572111800785813811467614971291858380424207212470984391167760694805331930671076508836978834832661887925799776640390840470977875974323060557817792235965552255885276226057560230583826658034583575801554695059047, 268979405122804393027170445530338446206610074742832867718235870457475626024942680826027972068483238903246745764920875307179316418909178761558070465939341662641793197823095292334590592800021790441975896979146907263444313097546935175608594332475985436351896079585299623851919343338824266834209570792007094916396719215272148044469796689662013572640280148250625383108400184325618687803818355414450557575712792024247281478742164458095028155116210812552094668489765384790292604864975666989160165230770573449907091076407504614433265625180391580977483917983831858464922447770185414815446860865289281855742507304882746806308667258925044364467364740363097016993746642009182837176837819962230359591693139409031241687572877844627566755145072816229129417335557343315356662961165699996512043446852934695488341048967406782608764841478879940658782647794264034547319866199830285283932601838086989657960652975690033258066348895790073241794014, 1521158362715155454097756931052727717878889869688712453486606517629270329777684406452036981546430242564656146926258714199957602504207629834143865996729006122009889382535315498401491725307558088861688867142674873316236088299621053183453269904865862625765686025696069252520191342674399759900363487828527390473331876374877066463173271550524728008041915614246144806074264715708703233530474446610975016681526269110640669256441069042633622793941942259576439672237348714735168439068342911261074945918185355498255850927504972534036307621100571535263476170038941793883514864519982892473549754232231586079824086768168302432512297722672301238996302640516015249179302849667304288360560228729309230540380560519733720817984973175451050660458649685273186719284955088708283941197117266321098232994179275405962963082204615237311233943307292001768528015035597262519767340674366161929437638853140199198272216964710062026811799480052533506554371]

q = gcd(cts[0] - cts[1], cts[2] - cts[3])
p = Ns[0] // q

for i in cts:
    flag = long_to_bytes(int(pow(i, pow(65537, -1, (p - 1) * (q - 1)), p * q)))
    if b"ASCIS" in flag:
        print(flag)
```

### 4. chal2

---

**__chall.py__**

```py
import random
import string
from Crypto.Util.number import isPrime

BLOCK_LEN = 129
CHARSET = string.ascii_uppercase + string.ascii_lowercase + string.digits
users, pwd_hashes = {}, []
allowed_blocks = []

q1 = 57895665874783536962369408363969823887021530656373208299565102620846005563716018275834077962292286213472570266375824572745671541793458387390711613089471407869558363212866932533545785125988453002675479793768261480181947144057144941974626043243654731721303589851520175899531854692118423229594279209070187162279
p1 = 2 * q1 + 1
g1 = 2

assert isPrime(p1)
assert isPrime(q1)
assert pow(g1, q1, p1) == 1

x1 = random.randint(1, 2 ** 256)
y1 = pow(g1, x1, p1)

def block_hash(block, bases, a):
    for x, y in zip(bases, block):
        a = a * pow(x, y, p1) % p1
    
    return a
def secure_hash(data, token, is_login = False):
    assert len(data) + 1 >= BLOCK_LEN, "Invalid Length"
    
    if len(data) % BLOCK_LEN != 0:
        data += b'\x80'
        data += b'\x00' * (BLOCK_LEN - len(data) % BLOCK_LEN - 1)
        
    blocks = [data[i:i + BLOCK_LEN] for i in range(0, len(data), BLOCK_LEN)]
    bases = [pow(g1, x, p1) for x in token] + [g1]
    yu_1 = y1
    
    for block in blocks:
        if all(x == 0 for x in block[:-1]):
            raise ValueError("No cheese this time")
        if is_login:
            if block not in allowed_blocks:
                raise ValueError("Invalid block")
        yu_1 = block_hash(block, bases, yu_1)
        allowed_blocks.append(block)
    
    return yu_1

def register(username, password):
    token = [random.randint(1, q1 - 1) for _ in range(BLOCK_LEN - 1)]
    if username in users:
        print("Username already exists")
        return False
    pwd_hash = secure_hash(password, token)
    users[username] = token
    pwd_hashes.append(pwd_hash)
    return True

def login(username, password):
    if username not in users:
        return False
    token = users[username]
    try:
        password.decode()
    except:
        print("Invalid password")
    pwd_hash = secure_hash(password, token, True)
    return pwd_hash in pwd_hashes

def breach(username):
    if username not in users:
        return None
    return users[username]

def menu():
    print("1. Register")
    print("2. Login")
    print("3. Exit")

def main():
    admin_username = "admin"
    admin_password = ''.join(random.choices(CHARSET, k = BLOCK_LEN - 1)).encode() + b'\x00'
    register(admin_username, admin_password)
    print(f'User {admin_username} registered successfully')
    for _ in range(5):
        try:
            menu()
            choice = int(input("> "))
            if choice == 1:
                username = input("Enter username: ")
                password = bytes.fromhex(input("Enter password: "))
                if register(username, password):
                    print(f'User {username} registered successfully')
            elif choice == 2:
                username = input("Enter username: ")
                password = bytes.fromhex(input("Enter password: "))
                if login(username, password):
                    if username == admin_username:
                        print("Welcome admin, here is your flag: ")
                        print(open("flag.txt").read())
                        exit()
                    else:
                        print(f"Welcome user {username}")
                else:
                    print("Invalid credential")
            elif choice == 3:
                print("Gud bye")
                exit(0)
            elif choice == 1337:
                victim = input("Give me the victim name: ")
                victim_token = breach(victim)
                print("Shhhhh, don't tell anyone about this")
                print(victim_token)
            else:
                print("Invalid choice")
                exit(0)
        except ValueError:
            print("No No No No")
    
if __name__ == "__main__":
    main()
```

---

#### 1. Tổng quan

+ Code của bài này khá dài nên mình sẽ chỉ đi qua nhưng phần chính để có thể giải quyết bài này.

+ Hàm `block_hash` như sau:

```py
def block_hash(block, bases, a):
    for x, y in zip(bases, block):
        a = a * pow(x, y, p1) % p1
    
    return a
```

ta có thể thấy như sau:

$$
a = \prod_i{{x_i} ^ {y_i}}
$$

mà `x = bases = [pow(g1, k, p1) for k in token] + [g1]` nên ta có thể viết 

$$
a = \prod_i{{g} ^ {k_i * y_i}}
$$

vì hàm login sử dụng kết quả `return pwd_hash in pwd_hashes` nên nếu hai ta gửi hai password với token khác nhau nhưng mà hai cái đó có chung hash thì ta vẫn có thể login thành công.

nên bài toán được đưa về như sau:

$$
a_1 = \prod_i{{g} ^ {k_i * y_i}} = a_2 = \prod_i{{g} ^ {k_j * y_j}} \\ 

\to \sum{k_i * y_i} = \sum{k_j * y_j}
$$

mà ta có thể biết được token của admin tức `y_i` cùng với một cặp `password`, `token` ta có thể lấy nữa, nó tương đương với `k_j`, `y_j` nên khi này bài toán được đưa về thành

$$
\to \sum{k_i * y_i} = {hash} \pmod{q}
$$
mình cần tìm 129 ẩn `k_i` thỏa mãn phương trình trên và yêu cầu các `k_i` >= 0 và cũng không quá lớn nê mình sử dụng `solve_linear_mod` để tìm. Khi tìm được các `k_i` ta phải gửi nó thành payload sao cho sau khi server nhận có thể decode được nên mình chia nhỏ các `k_i` thành các phần nhỏ hơn $127$ (giá trị lớn nhất mà UTF-8 có thể decode) và gửi tới server là có flag.

#### 2. Code

```py

from pwn import *

from sage.all import *
from tqdm import trange
from collections.abc import Sequence
import math
import operator
from typing import List, Tuple
from sage.all import ZZ, gcd, matrix, prod, var

def block_hash(block, bases, a):
    for x, y in zip(bases, block):
        a = a * pow(x, y, p1) % p1
    
    return a
def secure_hash(data, token):
    assert len(data) + 1 >= BLOCK_LEN, "Invalid Length"
    
    if len(data) % BLOCK_LEN != 0:
        data += b'\x80'
        data += b'\x00' * (BLOCK_LEN - len(data) % BLOCK_LEN - 1)
        
    blocks = [data[i:i + BLOCK_LEN] for i in range(0, len(data), BLOCK_LEN)]
    bases = [pow(g1, x, p1) for x in token] + [g1]
    yu_1 = 1
    
    for block in blocks:
        if all(x == 0 for x in block[:-1]):
            raise ValueError("No cheese this time")
        yu_1 = block_hash(block, bases, yu_1)

    return yu_1

def _process_linear_equations(equations, vars, guesses) -> List[Tuple[List[int], int, int]]:
    result = []

    for rel, m in equations:
        op = rel.operator()
        if op is not operator.eq:
            raise TypeError(f"relation {rel}: not an equality relation")

        expr = (rel - rel.rhs()).lhs().expand()
        for var in expr.variables():
            if var not in vars:
                raise ValueError(f"relation {rel}: variable {var} is not bounded")

        # Fill in eqns block of B
        coeffs = []
        for var in vars:
            if expr.degree(var) >= 2:
                raise ValueError(f"relation {rel}: equation is not linear in {var}")
            coeff = expr.coefficient(var)
            if not coeff.is_constant():
                raise ValueError(f"relation {rel}: coefficient of {var} is not constant (equation is not linear)")
            if not coeff.is_integer():
                raise ValueError(f"relation {rel}: coefficient of {var} is not an integer")

            coeffs.append(int(coeff) % m)

        # Shift variables towards their guesses to reduce the (expected) length of the solution vector
        const = expr.subs({var: guesses[var] for var in vars})
        if not const.is_constant():
            raise ValueError(f"relation {rel}: failed to extract constant")
        if not const.is_integer():
            raise ValueError(f"relation {rel}: constant is not integer")

        const = int(const) % m

        result.append((coeffs, const, m))

    return result


def solve_linear_mod(equations, bounds, verbose=False, **lll_args):
    """Solve an arbitrary system of modular linear equations over different moduli.

    equations: A sequence of (lhs == rhs, M) pairs, where lhs and rhs are expressions and M is the modulus.
    bounds: A dictionary of {var: B} entries, where var is a variable and B is the bounds on that variable.
        Bounds may be specified in one of three ways:
        - A single integer X: Variable is assumed to be uniformly distributed in [0, X] with an expected value of X/2.
        - A tuple of integers (X, Y): Variable is assumed to be uniformly distributed in [X, Y] with an expected value of (X + Y)/2.
        - A tuple of integers (X, E, Y): Variable is assumed to be bounded within [X, Y] with an expected value of E.
        All variables used in the equations must be bounded.
    verbose: set to True to enable additional output
    lll_args: Additional arguments passed to LLL, for advanced usage.

    NOTE: Bounds are *soft*. This function may return solutions above the bounds. If this happens, and the result
    is incorrect, make some bounds tighter and try again.

    Tip: if you get an unwanted solution, try setting the expected values to that solution to force this function
    to produce a different solution.

    Tip: if your bounds are loose and you just want small solutions, set the expected values to zero for all
    loosely-bounded variables.

    >>> k = var('k')
    >>> # solve CRT
    >>> solve_linear_mod([(k == 2, 3), (k == 4, 5), (k == 3, 7)], {k: 3*5*7})
    {k: 59}

    >>> x,y = var('x,y')
    >>> solve_linear_mod([(2*x + 3*y == 7, 11), (3*x + 5*y == 3, 13), (2*x + 5*y == 6, 143)], {x: 143, y: 143})
    {x: 62, y: 5}

    >>> x,y = var('x,y')
    >>> # we can also solve homogenous equations, provided the guesses are zeroed
    >>> solve_linear_mod([(2*x + 5*y == 0, 1337)], {x: 5, y: 5}, guesses={x: 0, y: 0})
    {x: 5, y: -2}
    """

    # The general idea is to set up an integer matrix equation Ax=y by introducing extra variables for the quotients,
    # then use LLL to solve the equation. We introduce extra axes in the lattice to observe the actual solution x,
    # which works so long as the solutions are known to be bounded (which is of course the case for modular equations).
    # Scaling factors are configured to generally push the smallest vectors to have zeros for the relations, and to
    # scale disparate variables to approximately the same base.

    vars = list(bounds)
    guesses = {}
    var_scale = {}
    for var in vars:
        bound = bounds[var]
        if isinstance(bound, Sequence):
            if len(bound) == 2:
                xmin, xmax = map(int, bound)
                guess = (xmax - xmin) // 2 + xmin
            elif len(bound) == 3:
                xmin, guess, xmax = map(int, bound)
            else:
                raise TypeError("Bounds must be integers, 2-tuples or 3-tuples")
        else:
            xmin = 0
            xmax = int(bound)
            guess = xmax // 2
        if not xmin <= guess <= xmax:
            raise ValueError(f"Bound for variable {var} is invalid ({xmin=} {guess=} {xmax=})")
        var_scale[var] = max(xmax - guess, guess - xmin, 1)
        guesses[var] = guess

    var_bits = math.log2(int(prod(var_scale.values()))) + len(vars)
    mod_bits = math.log2(int(prod(m for rel, m in equations)))
    if verbose:
        print(f"verbose: variable entropy: {var_bits:.2f} bits")
        print(f"verbose: modulus entropy: {mod_bits:.2f} bits")

    # Extract coefficients from equations
    equation_coeffs = _process_linear_equations(equations, vars, guesses)

    is_inhom = any(const != 0 for coeffs, const, m in equation_coeffs)

    NR = len(equation_coeffs)
    NV = len(vars)
    if is_inhom:
        # Add one dummy variable for the constant term.
        NV += 1
    B = matrix(ZZ, NR + NV, NR + NV)

    # B format (rows are the basis for the lattice):
    # [ mods:NRxNR 0
    #   eqns:NVxNR vars:NVxNV ]
    # eqns correspond to equation axes, fi(...) = yi mod mi
    # vars correspond to variable axes, which effectively "observe" elements of the solution vector (x in Ax=y)
    # mods and vars are diagonal, so this matrix is lower triangular.

    # Compute maximum scale factor over all variables
    S = max(var_scale.values())

    # Compute equation scale such that the bounded solution vector (equation columns all zero)
    # will be shorter than any vector that has a nonzero equation column
    eqS = S << (NR + NV + 1)
    # If the equation is underconstrained, add additional scaling to find a solution anyway
    if var_bits > mod_bits:
        eqS <<= int((var_bits - mod_bits) / NR) + 1
    col_scales = []

    for ri, (coeffs, const, m) in enumerate(equation_coeffs):
        for vi, c in enumerate(coeffs):
            B[NR + vi, ri] = c
        if is_inhom:
            B[NR + NV - 1, ri] = const
        col_scales.append(eqS)
        B[ri, ri] = m

    # Compute per-variable scale such that the variable axes are scaled roughly equally
    for vi, var in enumerate(vars):
        col_scales.append(S // var_scale[var])
        # Fill in vars block of B
        B[NR + vi, NR + vi] = 1

    if is_inhom:
        # Const block: effectively, this is a bound of 1 on the constant term
        col_scales.append(S)
        B[NR + NV - 1, -1] = 1

    if verbose:
        print("verbose: scaling shifts:", [math.log2(int(s)) for s in col_scales])
        print("verbose: unscaled matrix before:")
        print(B.n())

    for i, s in enumerate(col_scales):
        B[:, i] *= s
    B = B.LLL(**lll_args)
    for i, s in enumerate(col_scales):
        B[:, i] /= s

    # Negate rows for more readable output
    for i in range(B.nrows()):
        if sum(x < 0 for x in B[i, :]) > sum(x > 0 for x in B[i, :]):
            B[i, :] *= -1
        if is_inhom and B[i, -1] < 0:
            B[i, :] *= -1

    if verbose:
        print("verbose: unscaled matrix after:")
        print(B.n())

    for row in B:
        if any(x != 0 for x in row[:NR]):
            # invalid solution: some relations are nonzero
            continue

        if is_inhom:
            # Each row is a potential solution, but some rows may not carry a constant.
            if row[-1] != 1:
                if verbose:
                    print(
                        "verbose: zero solution",
                        {var: row[NR + vi] for vi, var in enumerate(vars) if row[NR + vi] != 0},
                    )
                continue

        res = {}
        for vi, var in enumerate(vars):
            res[var] = row[NR + vi] + guesses[var]

        return res

q1 = 57895665874783536962369408363969823887021530656373208299565102620846005563716018275834077962292286213472570266375824572745671541793458387390711613089471407869558363212866932533545785125988453002675479793768261480181947144057144941974626043243654731721303589851520175899531854692118423229594279209070187162279
p1 = 2 * q1 + 1
g1 = 2
BLOCK_LEN = 129
payload = "01" + "00" * (BLOCK_LEN - 1)
pwd = {}
s = process(["python3", "chal.py"])

s.sendlineafter(b"> ", b"1")
s.sendlineafter(b"Enter username: ", b"Minh")
s.sendlineafter(b"Enter password: ", payload)

s.sendlineafter(b"> ", b"1337")
s.sendlineafter(b"Give me the victim name: ", b"admin")
s.recvline()
pwd = {"admin": eval(s.recvline().decode()) + [1]}

s.sendlineafter(b"> ", b"1337")
s.sendlineafter(b"Give me the victim name: ", b"Minh")
s.recvline()
pwd["Minh"] = eval(s.recvline().decode()) + [1]

k = sum([i * j for i, j in zip(pwd["Minh"], bytes.fromhex(payload))])

xs = [var(f"x{i}") for i in range(BLOCK_LEN)]
f = sum([i * j for i, j in zip(xs, pwd["admin"])])

for bit in trange(11, 15):
    
    b = {i: (0, 2 ** bit) for i in xs}
    msg = list(solve_linear_mod([(f == k, q1)], b).values())
    print((sum([i * j for i, j in zip(msg, pwd["admin"])]) - k) % q1)
    admin_password = b""
    if all([i >= 0 for i in msg]):
        
        while any([x > 0 for x in msg]):
            for i in range(len(msg)):
                if msg[i] >= 127:
                    admin_password += bytes([127])
                    msg[i] -= 127
                elif msg[i] == 0:
                    admin_password += b"\x00"
                elif msg[i] < 127:
                    admin_password += bytes([msg[i]])
                    msg[i] = 0

        s.sendlineafter(b"> ", b"1")
        s.sendlineafter(b"Enter username: ", b"Mnh")
        s.sendlineafter(b"Enter password: ", admin_password.hex())
        s.sendlineafter(b'>', b'2')
        s.sendlineafter(b'username: ', b'admin')
        s.sendlineafter(b'password: ', admin_password.hex())
        s.interactive()
        exit()
```

++ link của solution chính thức của giải `https://ascis.vnisa.org.vn/en/writeup-for-crypto-challenges-ascis-2024/`