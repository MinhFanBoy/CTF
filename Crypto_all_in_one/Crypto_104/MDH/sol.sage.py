

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_60 = Integer(60); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_99986015309131554073222673357191122700463502810799771 = Integer(99986015309131554073222673357191122700463502810799771); _sage_const_11 = Integer(11); _sage_const_1399 = Integer(1399); _sage_const_576647 = Integer(576647); _sage_const_707717 = Integer(707717); _sage_const_31455197 = Integer(31455197); _sage_const_3252424492932335710113083947875131225240197576701027092531662276031618802648263217323062670742686213740942922979212534962194866012538868201949253298148367181530386764587695735363 = Integer(3252424492932335710113083947875131225240197576701027092531662276031618802648263217323062670742686213740942922979212534962194866012538868201949253298148367181530386764587695735363)
from tqdm import *
from hashlib import sha256
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Util.number import getPrime
from random import getrandbits
from Crypto.Util.number import *

def matrix_overview(BB):
    for ii in range(BB.dimensions()[_sage_const_0 ]):
        a = ('%02d ' % ii)
        for jj in range(BB.dimensions()[_sage_const_1 ]):
            if BB[ii, jj] == _sage_const_0 :
                a += ' '
            else:
                a += 'X'
            if BB.dimensions()[_sage_const_0 ] < _sage_const_60 :
                a += ' '
        print(a)

f = open("output", "r").readlines()

for i in f:
    exec(i.strip())

p = p
M = M
Ma = Ma
Mb = Mb
ct = ct

G = Zmod(p ** _sage_const_3 )
PR = PolynomialRing(G, names=('x',)); (x,) = PR._first_ngens(1)
M = matrix(G, M)
Ma = matrix(G, Ma)
Mb = matrix(G, Mb)

g = M.charpoly()
a = Ma.charpoly()
b = Mb.charpoly()

def binomial_dlog_sub(y,g,p,q,r=_sage_const_2 ):
    C = ZZ(pow(y, q, p**r))
    B = ZZ(pow(g, q, p**r))
    kx = (C - _sage_const_1 )//p**(r-_sage_const_1 )
    k =  (B - _sage_const_1 )//p**(r-_sage_const_1 )
    x = ZZ(kx * pow(k, -_sage_const_1 , p) % p)
    return x

def binomial_dlog(y,g,p,q,r):
    # solve y = g^x \mod p^r where q=phi(p) such that g^q = 1 \mod p
    assert r >= _sage_const_2 
    y = ZZ(y)
    g = ZZ(g)
    xs = []
    for i in range(r-_sage_const_1 ):
        xi = binomial_dlog_sub(y, g, p, q, i + _sage_const_2 )
        xs.append(xi)
        y = ZZ(y * pow(g,-xi,p**r) % p**r)
        g = ZZ(pow(g,p,p**r))
    return ZZ(xs, p)

def hensel_lift(f, p, k, i=_sage_const_0 ):
    """
    f: đa thức cần tìm nghiệm
    p: số nguyên tố
    k: số mũ của p muốn nâng lên (p^k)
    i: nghiệm thứ i của f mod p
    """
    fp = f.change_ring(Zmod(p))
    g0 = int(fp.roots()[i][_sage_const_0 ])
    
    result = g0
    power = _sage_const_1 
    
    for i in range(_sage_const_1 , k):
        
        curr_poly = (f(result + x * p**power).change_ring(ZZ) / (p**power)).change_ring(Zmod(p))
        ti = int(curr_poly.roots()[_sage_const_0 ][_sage_const_0 ])
        result = result + ti * (p**power)
        power += _sage_const_1 
        
    return int(result)



def d_log(k, base, p, r): 

    # solve k = base ^ x (mod p^r)
    
    def d_log_sub(k, base, p, r):

    # sol that: base ^ x = k (mod p ^ r) => find x

        q = p - _sage_const_1 
        c = (ZZ(pow(k, q, p ** r)) - _sage_const_1 ) // (p ** (r - _sage_const_1 ))
        d = (ZZ(pow(base, q, p ** r)) - _sage_const_1 ) // (p ** (r - _sage_const_1 ))
        x = ZZ((pow(d, -_sage_const_1 , p) * c) % p)

        return x
    
    k = ZZ(k)
    base = ZZ(base)
    xs = []

    for i in range(r-_sage_const_1 ):
        xi = d_log_sub(k, base, p, i + _sage_const_2 )
        xs.append(xi)
        k = ZZ(k * pow(base,-xi,p**r) % p**r)
        base = ZZ(pow(base,p,p**r))
    return ZZ(xs, p)

def d_log(k, base, p, r): 

    # solve k = base ^ x (mod p ^ r)
    R = Zp(p, prec = r)
    return (R(k).log() / R(base).log()).lift()

g1 = hensel_lift(g, p, _sage_const_1 , i = _sage_const_1 )
a1 = hensel_lift(a, p, _sage_const_1 , i = _sage_const_1 )

T = _sage_const_99986015309131554073222673357191122700463502810799771 
order = _sage_const_11  * _sage_const_1399  * _sage_const_576647  * _sage_const_707717  * _sage_const_31455197 

a_1 = discrete_log(Mod(pow(a1,T,p),p),Mod(pow(g1,T,p),p),ord=order)

g2 = hensel_lift(g, p, _sage_const_2 , i = _sage_const_1 )
a2 = hensel_lift(a, p, _sage_const_2 , i = _sage_const_1 )

a_2 = binomial_dlog(a2, g2, p, (p - _sage_const_1 ), _sage_const_2 )

g3 = hensel_lift(g, p, _sage_const_3 , i = _sage_const_1 )
a3 = hensel_lift(a, p, _sage_const_3 , i = _sage_const_1 )

a_3 = binomial_dlog(a3, g3, p, (p - _sage_const_1 ), _sage_const_3 )
# print(xa)
# print((pow(g3, xa, p ** 3) - a3) % (p ** 3))

a_ = crt([a_2, a_1], [p * (p - _sage_const_1 ), order])
print(a_)
a =  _sage_const_3252424492932335710113083947875131225240197576701027092531662276031618802648263217323062670742686213740942922979212534962194866012538868201949253298148367181530386764587695735363 
print(a - int(a_))

mod = (p) * order
while M ** a_ != Ma:
    a_ += mod
    print(a - int(a_))
S = Mb ** a_
key = sha256(S.str().encode()).digest()
print(AES.new(key, AES.MODE_ECB).decrypt(long_to_bytes(ct)))

