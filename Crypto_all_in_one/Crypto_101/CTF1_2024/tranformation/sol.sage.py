

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_423323064726997230640834352892499067628999846 = Integer(423323064726997230640834352892499067628999846); _sage_const_44150133418579337991209313731867512059107422186218072084511769232282794765835 = Integer(44150133418579337991209313731867512059107422186218072084511769232282794765835); _sage_const_1033433758780986378718784935633168786654735170 = Integer(1033433758780986378718784935633168786654735170); _sage_const_2890573833121495534597689071280547153773878148499187840022524010636852499684 = Integer(2890573833121495534597689071280547153773878148499187840022524010636852499684); _sage_const_875772166783241503962848015336037891993605823 = Integer(875772166783241503962848015336037891993605823); _sage_const_51964088188556618695192753554835667051669568193048726314346516461990381874317 = Integer(51964088188556618695192753554835667051669568193048726314346516461990381874317); _sage_const_612403241107575741587390996773145537915088133 = Integer(612403241107575741587390996773145537915088133); _sage_const_64560350111660175566171189050923672010957086249856725096266944042789987443125 = Integer(64560350111660175566171189050923672010957086249856725096266944042789987443125); _sage_const_40198712137747628410430624618331426343875490261805137714686326678112749070113 = Integer(40198712137747628410430624618331426343875490261805137714686326678112749070113); _sage_const_65008030741966083441937593781739493959677657609550411222052299176801418887407 = Integer(65008030741966083441937593781739493959677657609550411222052299176801418887407); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_9 = Integer(9); _sage_const_0x10001 = Integer(0x10001)

from Crypto.Util.number import *
P = (_sage_const_423323064726997230640834352892499067628999846 , _sage_const_44150133418579337991209313731867512059107422186218072084511769232282794765835 )
Q = (_sage_const_1033433758780986378718784935633168786654735170 , _sage_const_2890573833121495534597689071280547153773878148499187840022524010636852499684 )
S = (_sage_const_875772166783241503962848015336037891993605823 , _sage_const_51964088188556618695192753554835667051669568193048726314346516461990381874317 )
T = (_sage_const_612403241107575741587390996773145537915088133 , _sage_const_64560350111660175566171189050923672010957086249856725096266944042789987443125 )
eG = (_sage_const_40198712137747628410430624618331426343875490261805137714686326678112749070113 , _sage_const_65008030741966083441937593781739493959677657609550411222052299176801418887407 )
F = PolynomialRing(ZZ, _sage_const_2 , names=('c', 'd',)); (c, d,) = F._first_ngens(2)

lst = [P, Q, S, T]

eqs = [
    (u**_sage_const_2  + v**_sage_const_2  - c**_sage_const_2  * (_sage_const_1  + d * u**_sage_const_2 *v**_sage_const_2 )) for u, v in lst
]

I = F.ideal(eqs)
l = I.groebner_basis()

p = l[-_sage_const_1 ]
c_ = l[_sage_const_0 ].univariate_polynomial().change_ring(Zmod(p)).roots()[_sage_const_0 ][_sage_const_0 ]
d_ = l[_sage_const_1 ].univariate_polynomial().change_ring(Zmod(p)).roots()[_sage_const_0 ][_sage_const_0 ]

Curve = c_, d_, p 

def  twisted_Edwards_to_Montgomery(C):
    a, d, p = C
    A, B = (_sage_const_2  * (a + d) * pow(a - d, -_sage_const_1 , p)) % p, (_sage_const_4  * pow(a - d, -_sage_const_1 , p)) % p
    return (A, B, p)

def Montgomery_to_twisted_Edwards(C):
    A, B, p = C
    a, d = (A + _sage_const_2 ) * pow(B, -_sage_const_1 , p), (A - _sage_const_2 ) * pow(B, -_sage_const_1 , p)
    return (a, d, p)

def Montgomery_to_Short_Weierstrass(C):
    A, B, p = C
    a = (B ** _sage_const_2 ) * (_sage_const_1  - A ** _sage_const_2  * pow(_sage_const_3 , -_sage_const_1 , p)) % p
    b = B ** _sage_const_3  * A * pow(_sage_const_3 , -_sage_const_1 , p) * (_sage_const_2  * A ** _sage_const_2  * pow(_sage_const_9 , -_sage_const_1 , p) - _sage_const_1 ) % p

    return a, b, p
"""
u**2 + v**2 - c**2 * (1 + d * u**2*v**2) = 0 mod p


u ^ 2 + v ^ 2 = c ^ 2 * (1 + d * u ^ 2 * v ^ 2) mod p

c ^ -2 * (u ^ 2 + v ^ 2) = 1 + d * u ^ 2 * v ^ 2 mod p

want c ^ -2 * (u ^ 2 + v ^ 2) = (1 + d * u ^ 2 * v ^ 2) = a * u ^ 2 + * v ^ 2 mod p

a = 
"""
def ison(C, P):
    c, d, p = C
    u, v = P
    return (u**_sage_const_2  + v**_sage_const_2  - c**_sage_const_2  * (_sage_const_1  + d * u**_sage_const_2 *v**_sage_const_2 )) % p == _sage_const_0 
def add(C, P, Q):
    c, d, p = C
    u1, v1 = P
    u2, v2 = Q
    assert ison(C, P) and ison(C, Q)
    u3 = (u1 * v2 + v1 * u2) * inverse(c * (_sage_const_1  + d * u1 * u2 * v1 * v2), p) % p
    v3 = (v1 * v2 - u1 * u2) * inverse(c * (_sage_const_1  - d * u1 * u2 * v1 * v2), p) % p
    return (int(u3), int(v3))

def mul(C, P, m):
    assert ison(C, P)
    c, d, p = C
    B = bin(m)[_sage_const_2 :]
    l = len(B)
    u, v = P
    PP = (-u, v)
    O = add(C, P, PP)
    Q = O
    if m == _sage_const_0 :
        return O
    elif m == _sage_const_1 :
        return P
    else:
        for _ in range(l-_sage_const_1 ):
            P = add(C, P, P)
        m = m - _sage_const_2 **(l-_sage_const_1 )
        Q, P = P, (u, v)
        return add(C, Q, mul(C, P, m))
e = _sage_const_0x10001 
c = c_
d = d_

aa = _sage_const_1 
dd = (d * c ** _sage_const_4 ) % p

C_ = twisted_Edwards_to_Montgomery((aa, dd, p))
a, b, _ = Montgomery_to_Short_Weierstrass(C_)
k = EllipticCurve(Zmod(p), [a, b]).order()
k = pow(e, -_sage_const_1 , k)
G = mul(Curve, eG, k)
print(G)
assert (mul(Curve, G, e)==eG)
flag = "hgame{" + hex(G[_sage_const_0 ]+G[_sage_const_1 ])[_sage_const_2 :] + "}"
print(flag)

