

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_500000 = Integer(500000); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_69 = Integer(69); _sage_const_420 = Integer(420); _sage_const_1337 = Integer(1337); _sage_const_9001 = Integer(9001); _sage_const_11 = Integer(11); _sage_const_13 = Integer(13); _sage_const_17 = Integer(17); _sage_const_19 = Integer(19); _sage_const_72 = Integer(72); _sage_const_95 = Integer(95); _sage_const_237 = Integer(237); _sage_const_1001 = Integer(1001); _sage_const_64541532379927077000559872397264097749021972434205531336066931690486076647705413170185144940288988381635799051758671701941067093853968684354158364531117205968958931132385165913434941347527993061497902723498417954305499807823689010185704770834752024422286910181187814374841629893530443736915542004920807142781 = Integer(64541532379927077000559872397264097749021972434205531336066931690486076647705413170185144940288988381635799051758671701941067093853968684354158364531117205968958931132385165913434941347527993061497902723498417954305499807823689010185704770834752024422286910181187814374841629893530443736915542004920807142781); _sage_const_27 = Integer(27); _sage_const_35 = Integer(35); _sage_const_44022142978819419618353382999440345073976186907275599632322745080012623162430540188907724797065065001963223657911160722898910372812863352246726924386760519377252296888984296509586878063185483891399718374344520697641288446229397649573154526152818589294889851730684140323675940582528405188097712041985150863134 = Integer(44022142978819419618353382999440345073976186907275599632322745080012623162430540188907724797065065001963223657911160722898910372812863352246726924386760519377252296888984296509586878063185483891399718374344520697641288446229397649573154526152818589294889851730684140323675940582528405188097712041985150863134); _sage_const_36492103245285092647843551854942925373394229095706870054555977026553850101701906739652840770223455473246919620658344617649832752419944319254556813129428929352359138539967235739316345067424590082471814489355137379436050816028192665505036173068173821426333394966323037686047535779525861943853094214085274696593 = Integer(36492103245285092647843551854942925373394229095706870054555977026553850101701906739652840770223455473246919620658344617649832752419944319254556813129428929352359138539967235739316345067424590082471814489355137379436050816028192665505036173068173821426333394966323037686047535779525861943853094214085274696593); _sage_const_54800 = Integer(54800); _sage_const_20 = Integer(20); _sage_const_30 = Integer(30)
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes, getRandomInteger
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES
import numpy as np
import secrets
import hashlib
import random
import os
import logging

from sage.all import ZZ
from sage.all import Zmod

def _polynomial_hgcd(ring, a0, a1):
    assert a1.degree() < a0.degree()

    if a1.degree() <= a0.degree() / _sage_const_2 :
        return _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 

    m = a0.degree() // _sage_const_2 
    b0 = ring(a0.list()[m:])
    b1 = ring(a1.list()[m:])
    R00, R01, R10, R11 = _polynomial_hgcd(ring, b0, b1)
    d = R00 * a0 + R01 * a1
    e = R10 * a0 + R11 * a1
    if e.degree() < m:
        return R00, R01, R10, R11

    q, f = d.quo_rem(e)
    g0 = ring(e.list()[m // _sage_const_2 :])
    g1 = ring(f.list()[m // _sage_const_2 :])
    S00, S01, S10, S11 = _polynomial_hgcd(ring, g0, g1)
    return S01 * R00 + (S00 - q * S01) * R10, S01 * R01 + (S00 - q * S01) * R11, S11 * R00 + (S10 - q * S11) * R10, S11 * R01 + (S10 - q * S11) * R11


def fast_polynomial_gcd(a0, a1):
    """
    Uses a divide-and-conquer algorithm (HGCD) to compute the polynomial gcd.
    More information: Aho A. et al., "The Design and Analysis of Computer Algorithms" (Section 8.9)
    :param a0: the first polynomial
    :param a1: the second polynomial
    :return: the polynomial gcd
    """
    # TODO: implement extended variant of half GCD?
    assert a0.parent() == a1.parent()

    if a0.degree() == a1.degree():
        if a1 == _sage_const_0 :
            return a0
        a0, a1 = a1, a0 % a1
    elif a0.degree() < a1.degree():
        a0, a1 = a1, a0

    assert a0.degree() > a1.degree()
    ring = a0.parent()

    # Optimize recursive tail call.
    while True:
        logging.debug(f"deg(a0) = {a0.degree()}, deg(a1) = {a1.degree()}")
        _, r = a0.quo_rem(a1)
        if r == _sage_const_0 :
            return a1.monic()

        R00, R01, R10, R11 = _polynomial_hgcd(ring, a0, a1)
        b0 = R00 * a0 + R01 * a1
        b1 = R10 * a0 + R11 * a1
        if b1 == _sage_const_0 :
            return b0.monic()

        _, r = b0.quo_rem(b1)
        if r == _sage_const_0 :
            return b1.monic()

        a0 = b1
        a1 = r
from Crypto.Util.number import *
import sys

def HGCD(a, b):
    if _sage_const_2  * b.degree() <= a.degree() or a.degree() == _sage_const_1 :
        return _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 
    m = a.degree() // _sage_const_2 
    a_top, a_bot = a.quo_rem(x**m)
    b_top, b_bot = b.quo_rem(x**m)
    R00, R01, R10, R11 = HGCD(a_top, b_top)
    c = R00 * a + R01 * b
    d = R10 * a + R11 * b
    q, e = c.quo_rem(d)
    d_top, d_bot = d.quo_rem(x**(m // _sage_const_2 ))
    e_top, e_bot = e.quo_rem(x**(m // _sage_const_2 ))
    S00, S01, S10, S11 = HGCD(d_top, e_top)
    RET00 = S01 * R00 + (S00 - q * S01) * R10
    RET01 = S01 * R01 + (S00 - q * S01) * R11
    RET10 = S11 * R00 + (S10 - q * S11) * R10
    RET11 = S11 * R01 + (S10 - q * S11) * R11
    return RET00, RET01, RET10, RET11
    
def GCD(a, b):

    q, r = a.quo_rem(b)
    if r == _sage_const_0 :
        return b
    R00, R01, R10, R11 = HGCD(a, b)
    c = R00 * a + R01 * b
    d = R10 * a + R11 * b
    if d == _sage_const_0 :
        return c.monic()
    q, r = c.quo_rem(d)
    if r == _sage_const_0 :
        return d
    return GCD(d, r)

sys.setrecursionlimit(_sage_const_500000 )

from tqdm import *

# -(1 << 16) + 3000, 0 - > 2150
# for b in trange(2150, (1 << 16)):
#     c2_ = sum([a * (x + b) ** e for a, e in zip(a2, e2)])
#     k = (fast_polynomial_gcd(c1_ ** eB - cA, c2_ ** eA - cB))
#     if k != 1:
#         print(k)
#         break


e1 = [_sage_const_2 , _sage_const_3 , _sage_const_5 , _sage_const_7 ]
a1 = [_sage_const_69 , _sage_const_420 , _sage_const_1337 , _sage_const_9001 ]
e2 = [_sage_const_11 , _sage_const_13 , _sage_const_17 , _sage_const_19 ]
a2 = [_sage_const_72 , _sage_const_95 , _sage_const_237 , _sage_const_1001 ]

n = _sage_const_64541532379927077000559872397264097749021972434205531336066931690486076647705413170185144940288988381635799051758671701941067093853968684354158364531117205968958931132385165913434941347527993061497902723498417954305499807823689010185704770834752024422286910181187814374841629893530443736915542004920807142781 
eA = _sage_const_27 
eB = _sage_const_35 
cA = _sage_const_44022142978819419618353382999440345073976186907275599632322745080012623162430540188907724797065065001963223657911160722898910372812863352246726924386760519377252296888984296509586878063185483891399718374344520697641288446229397649573154526152818589294889851730684140323675940582528405188097712041985150863134 
cB = _sage_const_36492103245285092647843551854942925373394229095706870054555977026553850101701906739652840770223455473246919620658344617649832752419944319254556813129428929352359138539967235739316345067424590082471814489355137379436050816028192665505036173068173821426333394966323037686047535779525861943853094214085274696593 

iv = bytes.fromhex("922d9991e13113013496ada61eb3103c")
ciphertext = bytes.fromhex("5d2a59c1b5a5268baea17b095ad62310a0442eeeb2a6497f4074d70628f4ec5d51008a4ff12a6ea722e171656386f698ae530ac0824b0f5a77a93e2c063ac2f1")

F = PolynomialRing(Zmod(n), names=('x',)); (x,) = F._first_ngens(1)

# The public strengths of Generals Alicius and Bobius
eA = _sage_const_27   # Alicius' power
eB = _sage_const_35   # Bobius' power

c1_ = sum([a * x ** e for a, e in zip(a1, e1)])
for b in trange(_sage_const_54800  + _sage_const_20 , _sage_const_54800  + _sage_const_30 ):
    c2_ = sum([a * (x - b) ** e for a, e in zip(a2, e2)])
    k = (fast_polynomial_gcd(c1_ ** eB - cA, c2_ ** eA - cB))
    if k != _sage_const_1 :

        kA = int(-k.monic().constant_coefficient() % n)
        kB = int((kA - b) % n)

        c1 = sum([a * pow(kA, e, n) for a, e in zip(a1, e1)])  
        c2 = sum([a * pow(kB, e, n) for a, e in zip(a2, e2)]) 
        key = long_to_bytes(c1 + c2)
        key = hashlib.sha256(key).digest()
        cipher = AES.new(key, AES.MODE_CBC, iv)
        flag = cipher.decrypt(ciphertext)  
        print(flag)

