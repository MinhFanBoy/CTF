Tables_of_contens
================

**Hmm:**

Mình vừa tham gia giải leak_ctf xong, trong lúc giải diễn ra mình chỉ giải được 3/7 bài. Sau khi giải kết thúc mình vẫn giải nốt vài bài còn lại dựa vào một vài gợi ý từ các anh trong clb. Sau đây là toàn bộ wu của 6/7 bài mình đã làm được (Bài cuối khó quả chịu)


### 1. realy_simple_argorithm

---

**_server.py_**

```py
from Crypto.Util.number import getPrime, bytes_to_long as btl

menu = '''(1) Encrypt Message
(2) Receive Flag
(3) Exit'''

e = 1337
size = 1024
flag = open('flag.txt', 'r').read().rstrip()

print('Welcome to the L3ak Really Simple Algorithm (RSA) Encryption Service™!')
print('Here you can encrypt your own message, or choose to receive the encrypted flag.')
print('Good luck!\n')

while True:

    p, q = getPrime(size), getPrime(size)
    n = p*q
    print(menu)

    option = int(input('Select Option: '))
    if option == 1:
        message = btl(input('Your Message: ').encode())
        enc_msg = pow(message, e, n)
        print(f'n = {n}')
        print(f'c = {enc_msg}')
    elif option == 2:
        enc_flag = pow(btl(flag.encode()), e, n)
        print(f'n = {n}')
        print(f'flag = {enc_flag}')
    elif option == 3:
        print('Goodbye!')
        exit()
    else:
        print('Invalid choice! Please try again.')


```

---

Bài này khá đơn giản khi không có nhiều hàm hay tấn công nào đặc biết.

**Phân tích:**

+ server mã hóa flag bằng RSA 1024 bit bằng hàm get_prime của thư viện, mỗi lần kết nối tới thì ta sẽ có một số n mới.

```py
while True:

    p, q = getPrime(size), getPrime(size)
    n = p*q
```

+ Khi kết nối tới server thì ta có hai lựa chọn:

  + khi option = 1, thì ta có thể gửi một đoạn msg bất kỳ và server sẽ trả lại mã hóa của nó với e, n đã được tính sẵn của server.
 
    ```py
        message = btl(input('Your Message: ').encode())
        enc_msg = pow(message, e, n)
        print(f'n = {n}')
        print(f'c = {enc_msg}')
    ```
    
  + khi option = 2, thì thì ta nhận được mã hóa của server.

    ```py
        enc_flag = pow(btl(flag.encode()), e, n)
        print(f'n = {n}')
        print(f'flag = {enc_flag}')
    ```
**Solution:**

Mình nhận thấy như sau:

khi nhận được flag mã hóa của server có dạng ${flag} ^ e = enc \pmod{n}$

mà như đã phân tích ở trên thì hàm tạo khóa nằm trong hàm while True khiến cho mỗi lần nhận được enc của server thì n đều thay đổi nhưng e không thay đổi.

Khi nhận flag nhiều lần thì ta có:

+ ${flag} ^ {65537}  = enc_1 \pmod{n_1}$
+ ${flag} ^ {65537}  = enc_2 \pmod{n_2}$
+ ${flag} ^ {65537}  = enc_3 \pmod{n_3}$



khi đó mình coi ${flag} ^ (65537) = x$ thì ta sẽ có một hệ phương trình đồng dư x  = enc_3 \pmod{n_3}$

+ $x  = enc_1 \pmod{n_1}$
+ $x  = enc_2 \pmod{n_2}$
+ $x  = enc_3 \pmod{n_3}$
  
Sử dụng CRT(định lý phần dư Trung Hoa) ta có thể tìm lại được $x = x_0 + k * N$ với $\forall k \in R$ và $x_0, x$ là nghiệm của CRT. Sau đó ta có được $x = {x_0 + k * N} = {flag} ^ e$

khi đó ta chỉ cần chạy thử k từ 0 đến khi nào ta căn e ra flag là được, nhưng như thế sẽ rất lâu vì ${flag} ^ e$ rất lớn.

Thế nên mình nhận nhiều lần enc để tạo được nhiều hệ phương trình hơn từ đó khiến cho việc CRT trở nên chính xác với ${flag} ^ e$ hơn và chỉ cần căn e lại là có flag chứ không cần phải brute để tìm k.

**Code:**

Ban đầu, code của mình chỉ nhận và gửi 1 msg mỗi lần nên khá lâu thế nên mình đã áp dụng trick từ giải trước vào để tối ưu thời gian chay.

```py

from pwn import *
from gmpy2 import iroot
from Crypto.Util.number import long_to_bytes
from tqdm import tqdm


s = connect("193.148.168.30", 5668)
l = 15

ns = []
encs = []

payloads = b''

for j in range(l):
    payload = b''
    for i in range(50):
        payload += str(2).encode() + b'\n'
    payloads += payload 

s.sendlineafter(b"Select Option: ", payloads)

for ind in tqdm(range(l)):
    for i in range(50):
        s.recvuntil(b"n = ")
        n = int(s.recvline().strip())
        s.recvuntil(b"flag = ")
        flag = int(s.recvline().strip())


        ns.append(n)
        encs.append(flag)
        

print(long_to_bytes(int(iroot(crt(encs, ns), 1337)[0])))

```

### 2. related

---

**_chal.py_**

```py
import random
from flag import FLAG
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes

p = getPrime(1024)
q = getPrime(1024)
n = p * q
e = 0x101

def pad(flag):
    m = bytes_to_long(flag)
    a = random.randint(2, n)
    b = random.randint(2, n)
    return (a, b), a*m+b

def encrypt(flag):
    padded_variables, padded_message = pad(flag)
    encrypted = pow(padded_message, e, n)
    return padded_variables, encrypted

variables, ct1 = encrypt(FLAG)
a1 = variables[0]
b1 = variables[1]

variables, ct2 = encrypt(FLAG)
a2 = variables[0]
b2 = variables[1]

print(f"{n = }")
print(f"{a1 = }")
print(f"{b1 = }")
print(f"{ct1 = }")
print(f"{a2 = }")
print(f"{b2 = }")
print(f"{ct2 = }")
```

---

**Phân tích:**

Ban đầu, nó sẽ tạo ra các biến public key như sau:

```py
p = getPrime(1024)
q = getPrime(1024)
n = p * q
e = 0x101
```

sau đó flag sẽ được đưa qua hàm `pad`

```py
def pad(flag):
    m = bytes_to_long(flag)
    a = random.randint(2, n)
    b = random.randint(2, n)
    return (a, b), a*m+b
```

hàm này sẽ trả về hai biến a, b hoàn toàn ngẫu nhiên và a * m + b với m là tham số ta nhập vào

sau đó nó sẽ qua hàm encrypt như RSA bình thường

```py
def encrypt(flag):
    padded_variables, padded_message = pad(flag)
    encrypted = pow(padded_message, e, n)
    return padded_variables, encrypted
```

mình sẽ nhận được 2 cái flag đã mã hóa cùng với hai tham số a, b của mỗi lần mã hóa (đương nhiên là có cả public key nữa).

**Solution:**

Từ những dữ kiện đã có thì mình có thể tóm gon nó thành hai phương trình như sau:

+ $(a_1 * {flag} + b_1) ^ e = {enc_1} \pmod{n}$
+ $(a_2 * {flag} + b_2) ^ e = {enc_2} \pmod{n}$

Mình chuyển vế nó để đưa về dạng phương trình như sau:

+ $(a_1 * {flag} + b_1) ^ e - {enc_1} = 0 \pmod{n}$
+ $(a_2 * {flag} + b_2) ^ e - {enc_2} = 0 \pmod{n}$

Khi đó mình có thể ap dụng gcd để tính lại flag như sau:

![image](https://github.com/MinhFanBoy/CTF/assets/145200520/f74b9550-48a6-42f7-a161-a5ee1678fc27)

giả sử flag = x ta thấy

+ $(a_1 * {x} + b_1) ^ e - {enc_1} = 0 \pmod{n}$
+ $(a_2 * {x} + b_2) ^ e - {enc_2} = 0 \pmod{n}$

vì flag đều là nghiệm của phương trình trên nên ta có thể viết lại thành :

+ $(a_ 1 * {x} ^ 5 + b_1 * x ^ 4 ...) * (c_1 * {flag} - d_1)  = 0 \pmod{n}$
+ $(a_2 * {x} ^ 5 + b_2 * x ^ 4 ...) * (c_2 * {flag} - d_2)  = 0 \pmod{n}$

khi đó mình dễ thấy $(a * {flag} - b)$ = gcd($(a_ 1 * {x} ^ 5 + b_1 * x ^ 4 ...) * (c_1 * {flag} - d_1)$, $(a_2 * {x} ^ 5 + b_2 * x ^ 4 ...) * (c_2 * {flag} - d_2) $) = gcd($(a_1 * {flag} + b_1) ^ e - {enc_1}$, $(a_2 * {flag} + b_2) ^ e - {enc_2}$)

Và mình chỉ cần tính lại ${flag} = (-a)/b \pmod{n}$

Từ đó mình đã hoàn thành bài này.

**Code:**

```py

from Crypto.Util.number import *

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a.monic()
e = 0x101
n = 23446116820809956009508921267229329419806339208735431213584717790131416299556366048048977867380629435292555358502917305856047632651197352306945681062223443217527823509039445684919455982744684852068434951030105274549124012946448685060750456093120953320196777137936137902703756422225716380021864017594031233341531336018572970546112899850343992552126107820367629786159724290948728494321350895295087900001068499072242213916345639268473176748281877628559969801359815109260695490545357491404689132480248206287353580339535458835525161032145136894301169515951010316007454927062229765757932923091679510627796469997185047770119
a1 = 8104040836262507446864591234691358718164908580334110843106050982408624642389131164005601569999434432648709609777743793997208912520844943698036947408725027128235833538793471035056805185723079446135588491317378316082567779128276652380455054959975686544145446500257748715018799178783100289455255670805079936852471138049711583797615770901244436979110584710970079641409159097959783566594440737682826559724447739807028855072087914855150495360099989261682566388742966224528680792157619533719489447251411976029565538810357759752921276377948448704648350306514866111068184157760563297810978279434204440014428745729905509605285
b1 = 1728445028759460100268916851157941317747744991464848324630394207912877842639961858831903114707815701742483947978256582554473425946268457939887471248397622887505458768276338958573804608581353987536415380192782284575648580559755923454408763552113403890642303139141765381991794536720006159278517578791058556250982111713910060167032647218698362613084823406687399478088149985930840603408274198692032083156828441656375986195794109996772306557258447129571560905620272546405603257541870547380051900022925294193741417962861863860715434297040138205460211370506997331099668562619882982110566078451957682401843673938997454325985
ct1 = 7133574145118001624468851232768367610776481589816189114081484875167835285211475440236501712634938993477027789627285581268361018888589847771555770716521123959004389671272089766710340921550798461319697963644164596608774387203602804547184454077314801365322929817266934087883757605888082111393091270686060676504784482770435773757625762542094784777964406426404482882414828990658303263295993951921074284755818657012216398826105099627761519486438690405668440835527144374828045319113524249938249744799530870449189528166252037249009094063960558703857141043081099174412277124506544776530125652348821688752923438304710034397792
a2 = 6932198124642373427967232343817468902255209063707505631753623131468591968939116907766874533903771236309508029958603993113318003707536772796355326212684792901937391081839814883783063784050698582961314998290360613480778658142959804536224436521802834308095784814005774038096434723020316915995654759582638114351622288228138452404715021874261743824588698845194567350953613460211780903933501965152586633117799392776012574047439430079820078546000748259648002297803211427390366076552057374120223207399161502626197672749700677144769182115211864885324511059266535644202147069163420794861424973102200053615106664642762054707456
b2 = 17570492860498497589391311850810042101436988882059207563836745301643757694348737390349588510867234608796253222240056487274815481193573640552151307710984790365040907600873879523821340341063776797845384078798440533883164972773525749702026085462782235008812515983104980108840777316735468521572249232663287631112374534186975231033281807029801530398687397396929300293283833448151885674196708775598652356402354479252567714152805778278207736053329489014866155493921442482258381840272615320018058870234668488517354399053820878325928972260161611818894133121294554947400621261460441395783860055835185154356326202402937413717222
ct2 = 8778761624514690203726370366823530128900480928985439769115219364620387269991756967930541323829570453896164780238656562595733025340650482503284244625778872560261904887674968133049252085507078563540106328260114811619983171932648876602484063356832075687231100750407167402096299904835776594509894740386041222719008023556447633524625419665210188090816622517361786836014525679069179481575048514551967532281399777505866483289055530051032001545010914680661193107730444980281645735808124289602346876529763644878375393094200846185413267940739865639764057094273259729425291615810027734657664217752026488492540376475948687563210

PR.<x> = PolynomialRing(Zmod(n))

f_1 = (a1 * x + b1) ^ e - ct1
f_2 = (a2 * x + b2) ^ e - ct2

f = gcd(f_1, f_2)

print(bytes.fromhex(hex(- 1 * f.constant_coefficient())[2:]))

```

### 3. Pailient_tourist 

---

**_chal.sage_**

```py
from sage.all import *
from random import randint
from Crypto.Util.number import *

class Paillier:
    def __init__(self, bits):
        self.bits = bits
        self.pub, self.priv = self.keygen()

    def keygen(self):
        p = random_prime(2**self.bits)
        q = random_prime(2**self.bits)
        Lambda = (p - 1) * (q - 1)
        n = p * q
        Zn = IntegerModRing(n)
        Zn2 = IntegerModRing(n**2)
        g = Zn2(n + 1)
        mu = Zn(Lambda)**-1
        return ((n, g), (Lambda, mu))

    def encrypt(self, m):
        (n, g) = self.pub
        Zn2 = IntegerModRing(n**2)
        r = Zn2(randint(0, n))
        c = g**Zn2(m) * r**n
        return c

    def add(self, cipher_1, cipher_2):
        (n, g) = self.pub
        Zn2 = IntegerModRing(n**2)
        r = Zn2(randint(0, n))
        return cipher_1 * cipher_2 * r**n

    def sub(self, cipher_1, cipher_2):
        (n, g) = self.pub
        Zn2 = IntegerModRing(n**2)
        r = Zn2(randint(0, n))
        inv_cipher_2 = Zn2(cipher_2)**-1
        return cipher_1 * inv_cipher_2 * r**n

    def get_keys(self):
        return self.pub, self.priv

def toStr(msg):
    return long_to_bytes(int(msg))

# Generate key pairs
def main():
    paillier = Paillier(1024)
    pub_key, priv_key = paillier.get_keys()
    message_1 = randint(0, 420)
    cipher_1 = paillier.encrypt(message_1)
    message_2 = bytes_to_long(b"im so smrt, check me out mom")
    cipher_2 = paillier.encrypt(message_2)
    flag_message = bytes_to_long(b"L3AK{FAKE_FLAG_FAKE_FLAG}")
    flag_cipher = paillier.encrypt(flag_message)
    diff_cipher = paillier.sub(cipher_2, cipher_1)
    flag_cipher_modified = paillier.add(flag_cipher, diff_cipher)
    with open("challenge.txt", "w") as f:
        f.write(f"Ciphertext #1 = {hex(int(cipher_1))}\n")
        f.write(f"Ciphertext #2 = {hex(int(cipher_2))}\n")
        f.write(f"Modified Flag Cipher = {hex(int(flag_cipher_modified))}\n")
        f.write(f"Public Key = {hex(int(pub_key[0]))}, {hex(int(pub_key[1]))}\n")
        f.write(f"Private Key = {hex(int(priv_key[0]))}, {hex(int(priv_key[1]))}\n")
    

if __name__ == '__main__':
    main()
```

---

**Phân_tích:**

Mình sẽ phân tích các hàm của bài này trước:

+ Với hàm `key_gen` mình có:
  
  ```py

    def keygen(self):
        p = random_prime(2**self.bits)
        q = random_prime(2**self.bits)
        Lambda = (p - 1) * (q - 1)
        n = p * q
        Zn = IntegerModRing(n)
        Zn2 = IntegerModRing(n**2)
        g = Zn2(n + 1)
        mu = Zn(Lambda)**-1
        return ((n, g), (Lambda, mu))
  ```

  Tạo ra hai số prime p, q từ đó mình có hai trường Z(n), Z($n ^ 2$) rồi trả lại các tham số ((n, g), (lambda, $mu = {lambda} ^ {- 1}$)) và g = n + 1 (Cần nhớ cái này vì nó rất quan trọng)

+ `encrypt`

    ```py
        def encrypt(self, m):
            (n, g) = self.pub
            Zn2 = IntegerModRing(n**2)
            r = Zn2(randint(0, n))
            c = g**Zn2(m) * r**n
            return c
    ```

Hàm này đơn giản chỉ trả lại mình $enc = g ^ {m} * r ^ {n} \pmod{n ^ 2}$ với $r = {random}$

+ Hàm `add`

    ```py
        def add(self, cipher_1, cipher_2):
            (n, g) = self.pub
            Zn2 = IntegerModRing(n**2)
            r = Zn2(randint(0, n))
            return cipher_1 * cipher_2 * r**n
    ```

Nó trả lại ${c_1} * {c_2} * {r} ^ n \pmod{n ^ 2}$

+ Hàm `sub`

    ```py
        def sub(self, cipher_1, cipher_2):
            (n, g) = self.pub
            Zn2 = IntegerModRing(n**2)
            r = Zn2(randint(0, n))
            inv_cipher_2 = Zn2(cipher_2)**-1
            return cipher_1 * inv_cipher_2 * r**n
    
    ```

Trả lại ${c_1} * {c_2} ^ {- 1} * {r} ^ n \pmod{n ^ 2}$

Sau đó chương trình sẽ thực hiện các phép tính sau:

với msg_1 = randint(0, 420), msg_2 = b"im so smrt, check me out mom", msg_3 = flag. Vậy chúng ta có những gì

+ public_key
+ private_key
+ enc(msg_1), enc(msg_2), enc(msg_3)
+ modified = add(flag_cipher, sub(cipher_2, cipher_1))


**Phân_tích:**

có $enc = {g} ^ m * r ^ n \pmod{n ^ 2}$ và Lambda = (q - 1) * (p - 1)

từ đó ${enc} ^ {Lambda} = ({g} ^ m * (r) ^ n) ) ^ {Lambda} =  {g} ^ {m * {Lambda}} * (r) ^ {n * {Lambda}}  \pmod{n ^ 2}$ 

Mà ta có theo định lý Fermat: $r ^ {phi} = 1 \pmod{n}$ mà phi($n ^ 2$) = $n * (p - 1) * (q - 1)$ nên $r ^ {n * {Lambda}} = 1 \pmod{n ^ 2}$

$\to {enc} ^ {Lambda} =  {g} ^ {m * {Lambda}} = {(n + 1)} ^ {m * {Lambda}}$

![image](https://github.com/MinhFanBoy/CTF/assets/145200520/a2ec0240-4fe1-4b53-ab81-971cb637b955)

Theo wiki ta có:

$\to {enc} ^ {Lambda} = m * {Lambda} * n + 1 \pmod{n ^ 2}$

Thực hiện chia hai vế cho n, nhưng nên nhớ ở đây phần mod($n ^ 2$) cũng bị chia cho n nên phần mod chỉ còn lại n.

$\to ({enc} ^ {Lambda}  - 1) / ({Lambda} * n) = m  \pmod{n}$

$\to ({enc} ^ {Lambda}  - 1) / n * wu = m  \pmod{n}$ (vì $wu = {Lambda} ^ {- 1}$)

Từ đó ta có thể code lại được hàm decrypt như sau:

```py
def decrypt(c, priv):
	
	((n, g), (Lambda, mu)) = priv

	c = int(pow(c, Lambda, n ^ 2) - 1) // int(n) * mu % n
	
	return c
```

Tuy nhiên ta vẫn chưa có được flag luôn bởi vì nó còn đang bị mã hóa cùng với những msg khác. Tuy nhiên với nó ta có thể tìm lại được msg_1 = b"0x17"

với modified = add(flag_cipher, sub(cipher_2, cipher_1))

thì ta có như sau:

$${modified} = (g ^ {flag} * {r_1} ^ n) * (g ^ {msg_2} * {r_2} ^ n) * ((g ^ {msg_1} * {r_2} ^ n) ^ {- 1})$$

$${modified} = (g ^ {flag + msg_2 - msg_1} * {(r_1 * r_2 // r_3)} ^ n)$$

Sử dụng hàm decrypt trên thì ta có lại được flag + msg_2 - msg_1, việc còn lại chỉ là trừ lại là xong vì msg_1, 2 đều đã biết

**Code:**

```py

from Crypto.Util.number import *

def decrypt(c, priv):
	
	((n, g), (Lambda, mu)) = priv

	c = int(pow(c, Lambda, n ^ 2) - 1) // int(n) * mu % n
	
	return c

enc_1 = 0x14060da59e64dc74087b911f612d2c45d8253cb3d7cb322b3aea545b05460880b7c5cd99cdaad15d2bf7b92a5315c9cf6e1c962ebb1100e1b9d0b5f768419069cb4e53281c15d8a432f90ad33c6a3680c7a56df8680bf22765b4b5977bc30cdb49ea1dab83694268bf6869dcd587a8be2475330c339d441e8ce254559c3fe5e2b0296dd0239924e318d86b4c9f2babd2b49bf103fb6cc340e0bffe0dac3fda06aeb1e763f9d6713d62aee4aa9b7806b9dd1f311a528cd9531d997dfe31190f457af2576a79e4f873da57a28da763e07037dd6c7d14ef978bdcb857c7559ebe774c8db2ca34fc5841df1362ae768db89690216594c48ef23bd131618c3978a3bb36d420907947d862490376e20a9af43583960641b37a5733ee4082f8eb750d30eb8177e8af1d2589785b81d7e74c9ad386ef8280bc6c0d275bb95bb0cffd8b3e73db2e438880ff2f7bdd2bdfc0c8f3ee5265196d11eb9e4f5db8d643d5dc2d7c5372bad82d62cd2966ce033c5c609db288ef8484a664f4e33d19ce218ced0e7f46256c41d827813f4cb65425240762cc6e1c87421ff851c50f0c011e39655640bf3b8db0f43cb5ed93fb1967209d446d996c29abd76fa952fe31050b85d0e350dddc924421c3606d686e72d5764e0a596c95607ecb92a7cc7fe8c8b031e2877774f7df1e842107a4048306449ca7d66eb0cbfcd13b6b6cd3e2ae719b8e20530
enc_2 = 0x50258985886970e93e6b0105d26e42efe033a8216f721eaf981f89e9287b04ddfe5f16d3f6fcef6e814376c266e6738b29e47eb70b97fa9ff03e0e29e17d32d131550b94df94b7484f73592ecd15848594e9fc93e3401848b437bd6a8c67159c5410a32eebeab7285365ea69bfeeaaef975af1dd55c250bc30c709cdc631aa678f7e2795c6c5d66187974de4c6bfb30da14a9f9a91fcac9eccb463196d621ecdbeda28d682401c960a2dca58730766a6cecb83630ca92523b5bdd7c97019adc1754d0598d082cf51337e434bd2683d70ca074c276dc0e386a3a9a9ef189eff84a2acbdd7c1891c113589244d41d541dbc7a88639ab05b3c57cdd8fdfdbc7d3a9619bb8b0db85ce3e66640d2e1821da55ebdfb09e73230a08ad49d72707d4639763c8196568eb5654466743dd66c6cf37fafc97004aa0c063f54b145fb8d33dea6eb371af6e66d3e6fb3fa082712b5e4ad70580808fd650cc056aa17a88cc4ad0387701237f81a7039071aac653314a7dfe6fccd2b1e87cdf43832425a97ff9c5383133b6e984d9fb2132a80ee9b05cc7a2a493f9bc2197ba940826cdedd667a515d1554539eabc1ebdc9dd2075b80f98fa5e125a78891e64eb57f5e5eba97200d5c76f5d49646eda8671f5d289c1f8ca7c5033466b636052f10fbf0026c3c15f19b805271f9322a1c674cc33f69b725feb8a9087c05cc490c63fb467f499d9f
enc = 0x410f09e83a921ff2e06f9af688d56962be6b6db5472d84c802c89505bc80dcb06f09fba8cea712f3bd0af654b1e9c7010a20fe4bee9537c3e44771b90547103f9a313df10de3df68862c98ce7bfff47dc0547b65867b0990fd9ac496bf8e5df6c4fc8ad2ad074fb5083532dbb1f2373b9183770e2fda35498fa1753bb8ec4b1fcf80f100ae20eb8e865ef80e46435f75ec998af6cebb64717d76af38f926470207b8753bd94c0e55d7eaf7a5c352d718feead815aa886e585865c812f840da04fa24f411fc5917efcfc7549a41a22aed031842309709d93eb4818c62a00614f0ac13ac909454cb56780658d6188f813ba77ae52b76b2979423d9e62118a17114b8572a3219fda1e9399d91249fbb32b4e06615ce91de513f14231f42fe6b1e27027a22841554399b5c699a68dd308f0d11ed00580d703e9ea61710378b06bf3e55a4c6405e523184a3f4f9838c06ee650c7002b69106c8d7569c7f0628093fe61acbd2ce52654f6ebed132789daba9b26b989e3c6283326dec6c63df9ecfb60620cac002e680691d3cb8e4b4139596973a333eb5942f8512919e6b338631675c2c9ab58115aeaee009870a2a3d121c16574476211cdac81b78618f101315c694005ab7478546538e43559c3d29fb9508a1ca5a6e7afc046d0b450165f34ed611156ab9485adffd118013f8477ed8b7cf95f9008d0f140226644c99920af5633
n, g = 0x250fb952a1b9ed84701fa2fe7b90615e4144635d26a566231e2eeefae591c74fdf8a775425cf26ee84b48460417ff1859f4279c703258b325e7196656293c9225db58a9b6054fa83a2e44fc00eb058dd3e1660fbdc79cfd427aa90b0e0efdc40e02753c715ea9e7de1f282554d99c22ba883ca433577f8eac31dcfa55117c933cb69c969d91065a5276eb07e81caaf4fb332cc0f40cf5c049b8e8c78288f7b7a7d71fc5e1dba03eab6359bca909157e8a422c03ec852ae8b6fd8eaf7a37b2e3b680448f42724a3431aa73df3debdc052791ee2d0d57499fa2f1a21cb10bfdd14c148545d59fb7c90b679d44d4ad298ea6e15f4782faf9c53b8c3cda7536f11a5, 0x250fb952a1b9ed84701fa2fe7b90615e4144635d26a566231e2eeefae591c74fdf8a775425cf26ee84b48460417ff1859f4279c703258b325e7196656293c9225db58a9b6054fa83a2e44fc00eb058dd3e1660fbdc79cfd427aa90b0e0efdc40e02753c715ea9e7de1f282554d99c22ba883ca433577f8eac31dcfa55117c933cb69c969d91065a5276eb07e81caaf4fb332cc0f40cf5c049b8e8c78288f7b7a7d71fc5e1dba03eab6359bca909157e8a422c03ec852ae8b6fd8eaf7a37b2e3b680448f42724a3431aa73df3debdc052791ee2d0d57499fa2f1a21cb10bfdd14c148545d59fb7c90b679d44d4ad298ea6e15f4782faf9c53b8c3cda7536f11a6
Lambda, mu = 0x250fb952a1b9ed84701fa2fe7b90615e4144635d26a566231e2eeefae591c74fdf8a775425cf26ee84b48460417ff1859f4279c703258b325e7196656293c9225db58a9b6054fa83a2e44fc00eb058dd3e1660fbdc79cfd427aa90b0e0efdc40e02753c715ea9e7de1f282554d99c22ba883ca433577f8eac31dcfa55117c933057d339c308438050366c6b40808a18b4448dfe495c06abe52abdaaeb86381c86a14ad5d91ff1b25aaf1e82d0e429c8622cd435389169a066357ef488c1725ec0812d3a8edd7bc93d5ac7344c074169dbfd52949913cb9779ce1f7aab96b9a8a554fb17493075a862ab37d30ea4fe91e5ee6f9b95e280b297e91357454800c60, 0x21c0ff97d130be489dd28344be8a9022b1ecbca51a8555c52e3512f65786623289f7effbda90d9e52e3066af88464b5157984983fdbd4a0a60eea984bb427230d6f4e0de54954ccc8efc58127b58fb02fed0ea47f4bd28072be2e02fa58abf65d15a644a55f847feca9e29596aa9fb6137d0bfa68c1a69e1f425f20063c8bf256b7aa3920b149169ca4cabbe2c3668d8edbca2d0f7e7d0d131397a0b102339f6824153f7b6bc7837f255dd947ef53607e0ef91f08665e9125fc374689c3d515985d28313e1b9d4c2554e8780bb485f3e7c5999a30b94d2b5d0762b5adf7a031782a0488249ca109e9590aa9e611ed2dbc4ea9758d397d30ce11b0f8c2a683bc6

msg_1 = randint(0, 420)
msg_2 = bytes_to_long(b"im so smrt, check me out mom")


priv = ((n, g), (Lambda, mu))

print(long_to_bytes(int(decrypt(enc_1, priv))))
print(long_to_bytes(int(decrypt(enc_2, priv))))
print(long_to_bytes(int(decrypt(enc, priv) - msg_2 + 0x17)))


```
### 4. RSAn't

---

**_Chal.py_**

```py
from random import *
from sage.all import *
from Crypto.Util.number import *
from secret import flag

def encrypt():
    tmp = randint(2**1023, 2**1024)
    p = next_prime(1337*tmp + randint(2, 2**512))
    q = next_prime(7331*tmp + randint(2, 2**512))
    N = p*q
    return N

def l3ak(n):
    print('Security Alert!!')
    print('There is a L3AKER l3aking our data!! [~] :/\n')
    c1 = pow(bytes_to_long(b"factoring modulus?"), e, n)
    c2 = pow(bytes_to_long(b"without the modulus?"), e, n)
    return c1, c2

e = 65537
n = encrypt()
enc = pow(flag, e, n)
c1, c2 = l3ak(n)

print(f'Encrypted flag = {enc}\n')
print(f'c1 = {c1}\n')
print(f'c2 = {c2}\n')

```

**_output.txt_**

```py
e = 65537

ciphertext = 179299686848994539141122382962230037744384497621603198124077003991636319769603564062817092353600906591207476251327282277695110268704615120068654776183507204512702766847930125900500659983050185274344899025779726523565280032908194763356944549824963215339419038543390439655210741510143003582737996617770895692162306286064421718892797213765237300926925675153074894532935937291295802157305724856321584517131226940140190491157709894421683196766707672593154406263054436900566231464719102312973247466510418770039194000878897515838985623461176782628261365771619698859295767451162504151010728056594695117040661023327968023451519804564

c1 = 123377882241082251325350065419048806024607608617091688983830323277604694641240653374439302807138122463323990418348747537591347656262195555533468416119550902963546537686539626424151682647446653286178409257716563958279306978514921053134482777035689209563599648603507287706662378931300585730154813000147325737518201568052630101704051194396183990174893718130243703251255733422231215114594356086085529845721945162634747194330158630722370297888040809287372214916411109961066039419282486341414973486625115394106601990911459069075609672097833893961312251252396858703096951885954537748265354572684903035976149443662164781331591137509

c2 = 216996462348882812127549126696128848915007479735759067925583940914005783704777739383583486500248026532990006813147882357469539758674416271697210195684094572116588619081813131930186778045755089586040232978039441432232050042271853194470413044599117641325812011411950889172242559099135026172425733801215110286748370156962444409678069139574351948837982999861835569715249682828276876910129256029485173183675521926552841364713489224945222100475996799601024631599522598983661501357640196487134275394097207489818217501235732511301942649024362999538093008833593968191799917057618382726046836320499881842515455356124359654138411130319

```

---

**Phân tích:**

```py
def encrypt():
    tmp = randint(2**1023, 2**1024)
    p = next_prime(1337*tmp + randint(2, 2**512))
    q = next_prime(7331*tmp + randint(2, 2**512))
    N = p*q
    return N
```

+ Với hàm `encrypt` trên thì ta dễ thấy nó sẽ trả lại một số tự nhiên $N = q * p = (1337 * tmp + a) * (7331 * tmp + b)$

```py
def l3ak(n):
    print('Security Alert!!')
    print('There is a L3AKER l3aking our data!! [~] :/\n')
    c1 = pow(bytes_to_long(b"factoring modulus?"), e, n)
    c2 = pow(bytes_to_long(b"without the modulus?"), e, n)
    return c1, c2
```

+ Còn hàm leak sẽ trả lại cho ta giá trị mã hóa của hai msg mà ta đã biết trước là msg_1 = b"factoring modulus?"), msg_2 = b"without the modulus?"

Và phần còn lại thì ta biết thêm được e = 65537, và enc_flag (enc_1, enc_2).

**Solution:**

Theo mình thấy những bài thế này ta thường phải đi tìm hệ số modulus trước thì mới có thể bắt đầu tính toán được. Dựa vào những điều ta có thì mình có thể lập được hệ phương trình như sau:

+ ${msg_1} ^ e = {enc_1} \pmod{n}$
+ ${msg_2} ^ e = {enc_2} \pmod{n}$
+ ${flag} ^ e = {enc} \pmod{n}$

khi đó mình chuyển vế để đưa về dạng phương trình:

+ ${msg_1} ^ e - {enc_1} = 0 \pmod{n}$
+ ${msg_2} ^ e - {enc_2} = 0 \pmod{n}$

Theo tính chất của trường dư mình có thể suy ra:

+ ${msg_1} ^ e - {enc_1} = a * n$
+ ${msg_2} ^ e - {enc_2} = b * n$

$$gcd({msg_1} ^ e - {enc_1}, {msg_2} ^ e - {enc_2}) = gcd(a * n, b * n) = n$$

Từ đó mình có thể tim lại được n.

Ngoài ra mình có :

+ $N = q * p = (1337 * tmp + a) * (7331 * tmp + b) = 1337 * tmp * tmp * 7331 + tmp * (1337 * a + 7331 * b) + a * b$

ở đây cần nhơ rằng a, b rất nhỏ so với n nên ta thấy:

 + $\sqrt{N} = \sqrt{q * p} = sqrt{(1337 * tmp + a) * (7331 * tmp + b)} = sqrt{(1337 * tmp * tmp * 7331 + tmp * (1337 * a + 7331 * b) + a * b)} \approx sqrt{(1337 * tmp * tmp * 733)}$

$$\to tmp \approx \sqrt{ ^ n / _{(1337 * 7331)}}$$

từ đó ta có thể tim lại nhiều bit đầu của q bằng $tmp * 7331 = {q_leak}$

mình xây dựng phương trình $f = {q_leak} + x = 0\pmod{n}$ khi đó ${q_leak} + x$ là một nghiệm của phương trình nên nó sẽ là q hoặc q và từ đó mình có thể factor n và tính lại flag một cách dễ dàng.

**Code:**

```py

from Crypto.Util.number import *
from gmpy2 import iroot
from tqdm import *
import itertools

e = 65537

ciphertext = 179299686848994539141122382962230037744384497621603198124077003991636319769603564062817092353600906591207476251327282277695110268704615120068654776183507204512702766847930125900500659983050185274344899025779726523565280032908194763356944549824963215339419038543390439655210741510143003582737996617770895692162306286064421718892797213765237300926925675153074894532935937291295802157305724856321584517131226940140190491157709894421683196766707672593154406263054436900566231464719102312973247466510418770039194000878897515838985623461176782628261365771619698859295767451162504151010728056594695117040661023327968023451519804564

c1 = 123377882241082251325350065419048806024607608617091688983830323277604694641240653374439302807138122463323990418348747537591347656262195555533468416119550902963546537686539626424151682647446653286178409257716563958279306978514921053134482777035689209563599648603507287706662378931300585730154813000147325737518201568052630101704051194396183990174893718130243703251255733422231215114594356086085529845721945162634747194330158630722370297888040809287372214916411109961066039419282486341414973486625115394106601990911459069075609672097833893961312251252396858703096951885954537748265354572684903035976149443662164781331591137509

c2 = 216996462348882812127549126696128848915007479735759067925583940914005783704777739383583486500248026532990006813147882357469539758674416271697210195684094572116588619081813131930186778045755089586040232978039441432232050042271853194470413044599117641325812011411950889172242559099135026172425733801215110286748370156962444409678069139574351948837982999861835569715249682828276876910129256029485173183675521926552841364713489224945222100475996799601024631599522598983661501357640196487134275394097207489818217501235732511301942649024362999538093008833593968191799917057618382726046836320499881842515455356124359654138411130319

msg_2 = bytes_to_long(b"without the modulus?")
msg_1 = bytes_to_long(b"factoring modulus?")

# n = gcd(msg_1 ^ e - c1, msg_2 ^ e - c2)

n = 573705313470237088128697724011345537729683894813773026784491075891375787623474876644061916906451471924722277144379030941570465205946833957200688304499122972757670018621482568140886956686009200092360197152239823056384412058625497863977546406937961142478700220534582896797390680947594209881481624425897931034297127910081669705880067174821720273642918776110649889916889528110735095592416817545242751005238512957101272680451113761426278203742295886722523975429342004312924930404678014280113729314434769051596435530057776346632601974236264442330943600999709043920136852080203441976582246277392355669576484507651557516413526616046
n //= 2

q_leak =  7331 * isqrt((n)/(1337*7331))

PR.<x> = PolynomialRing(Zmod(n))

f =  q_leak + x
lst = f.small_roots( X = 2 ^ 513, beta = 0.5, m = 4)
print(lst)
q = int(q_leak + lst[0] % n)

p = n // q

print(bytes.fromhex(hex(pow(ciphertext,pow(e, -1, (p - 1) * (q - 1)), n))[2:]))
```

### 5. Magic matrix

---

**_chal.sage_**

```sage

from sage.all import *
from Crypto.Util.number import getPrime, isPrime
import os

def get_random(n):
    return int.from_bytes(os.urandom(n//8  + 1), "big")

def get_safe_prime(nbit):
    result = 2 * getPrime(nbit // 2) * getPrime(nbit // 2) + 1
    while not isPrime(int(result)):
        result = 2 * getPrime(nbit // 2) * getPrime(nbit // 2) + 1
    return result


FLAG = int.from_bytes(open("flag.txt", "rb").read().strip(), "big")

nbit = 1024

p = get_safe_prime(nbit // 2)
q = get_safe_prime(nbit // 2)
n = p*q

Mat = matrix(Zmod(n), [
    [2, 1] + [get_random(nbit) for _ in range(4)],
    [0, 2] + [get_random(nbit) for _ in range(4)],
    [0, 0] + [4, 1] + [get_random(nbit) for _ in range(2)],
    [0, 0] + [0, 4] + [get_random(nbit) for _ in range(2)],
    [0, 0] + [0, 0] + [8, 1],
    [0, 0] + [0, 0] + [0, 8]
])

C = Mat^FLAG
C = list(C)

with open("output.txt", "w") as f:
    f.write(f"{C = }")
```

**_output.txt_**

```py
C = [(34285747519707996626385667339662460790207453899564234933279840884637317470277963204844978855648863282661822817842406467276103235437115285776600339324582650206354227684286926765912841373720037206104315460984467834472878792871363724319500026730744559032592830317957861116684230815080884748210510265257121727411, 82389813574193236731268728055226346949935905889688170425892513962291738546070054175286986817742962125712704451033935523159914920684418980229184675189392660990212113237529057511102468180315624316711603102279872782413287481544411903032504611191117588506754985276936284421146109462510942343677179125102460355334, 127247078267314356402767966557448505733207679608121587776826570427528349536126399258128998506925096202352385266899982179247602157054605592001529350471426605916092686761690699179270970709575073044160148478140835495982904453410049961250136921488023338211130908836050232268149658252094451825981649386429967157023, 110997696050305177374684801376195205614043414698289134283464488914579055650336577562089998807469786126102628845652757901772021003891120075086100794690060492018372114798499796476503564426511552576093110306562634265833200794380828146503816203682087385703698944330589010185628240036153869595329794474678963954269, 95429943964904023259514531987953637596024020044100694025548029082876352647190904910373013883591092911247251504859346180249828148105405110896981416324094823746473360350150849817138654025822760100976625537661710179191573475427725481576122332324895773326199055069720422096583714906980119788052757109463536989130, 76925650644921944564121660415039326382672571942134701742579804900375156897677412516140878223663671839157682242947665571676520752706843330108967323669457404588586535061237444710279897627741144122937187393054928934936687732687921193790751566393662886825169077208127284176632544803227991370949818150005932210304), (0, 34285747519707996626385667339662460790207453899564234933279840884637317470277963204844978855648863282661822817842406467276103235437115285776600339324582650206354227684286926765912841373720037206104315460984467834472878792871363724319500026730744559032592830317957861116684230815080884748210510265257121727411, 85967636444726554256032386847538080607273641997139556709873191645024773479482183751659433639594934875197169824518560503372716992088412826701271790577397701838066670897181757432783438839115526851698428389903365201752735197054876789440370911041505435306549154757322168278884403206082946661059841799276902279607, 110321848943899292929831522195898953167052692821484311182642200713072229078674653831094653900345561159369211814825383018259327689455180388330932020089176571654576145870074563603252413779245365342554600824303390696086590372070050354595330074227342114164575397697848706436203854215556384244963529017935602600689, 55321436108075224950728586469455754360500596962017688262306497027259209074949803121055336152763619653715618911652213266949708309957674991371935559144633368828172207173145372615220450607178667764319048810554905786212377479905241378131059006116348325599909367174854478256625377537634718283487921887388679931300, 121048214328487578063535470984430739166205977393814304445813791572773220134359940700786671669567539273399625221907347167959074671295760177948556479010579225978917918535032412717072730223986401267581116138177971941402742413385270319230751393845616816965070450211819298226894334399356881715479006792296977303116), (0, 0, 80891788386112939497749276978496951092908047537517752191112348346041605282820278415204830919700840360371114407873821260986140627885494462923855784343766007471406691139724032186081486065167152331309928933439563087594932165713814698240940689654799590764311096627705559355661741126880749623083953480524440103996, 98127807327139994371479310755482264253499077621954160265776803909962087269443207623777017430975688540885576031084499718360878131623357206459366594111595569751254398053416214104147757969318816248746123610412479211529236153906708864168414330919431944363564172025204269508207805032491500543298879609362168155698, 65511482182385099252523608525317643713139065614405324455763784441479732896196144143630212812577305057210145612770975280343168022555945650814573970996890826522557999047275529322348420693034478105886809355222570889445527587635177667364042090723912339748512431185136779345494523747668733698804934976215893958288, 47395420931311533463576620820998773093140094423967370338777509171164699213419123512474441784558146041667540557107610725716163070022770572094504815720978368593469076026134774205916872923158523446883115622548066715665889163816586554653727221255672945695748970848307935789400330008330191289067490505817853508862), (0, 0, 0, 80891788386112939497749276978496951092908047537517752191112348346041605282820278415204830919700840360371114407873821260986140627885494462923855784343766007471406691139724032186081486065167152331309928933439563087594932165713814698240940689654799590764311096627705559355661741126880749623083953480524440103996, 19698820472058378412126192842030797220400882933373012220982539297272840493833295012123104281630408975161684583174403520414441877705582176563034772573895923595952612217426667572338807473485060098014543992573292667351072747962727283791740574278403611513201362656878372277715791010274896917611983518661952140153, 123510953871821884312855093053364645536177520009689630246292371010124299893864894909800725518340823661094473516585146142340021906280407678497822070318952778328284650261834023459467329786786889648844029738405121401290299843929018994002831246816483309594538299064894303565350991068375984784398159294612728278815), (0, 0, 0, 0, 36580210170460317737762146444885635769591964296289890711389087000847139534806165797517572963756420701630101713343229692997790887039708011239887899158602488099058023454307392387825436996066794401349180417178870019892425641929320878895403740655587101563655595067050855919740156100994268635382369423383067032821, 39071393947194921035771816301731926515001496696996162605545586710593160202215733075781810261530483080161843001707288615255381706789857593381598670763208249387924275996361728526530257131514765795139507343167639937751870811497537961210868263876827751668386006289349446841212411861730197725192485058916383785937), (0, 0, 0, 0, 0, 36580210170460317737762146444885635769591964296289890711389087000847139534806165797517572963756420701630101713343229692997790887039708011239887899158602488099058023454307392387825436996066794401349180417178870019892425641929320878895403740655587101563655595067050855919740156100994268635382369423383067032821)]
```

---

**Phân Tích:**


```py
def get_random(n):
    return int.from_bytes(os.urandom(n//8  + 1), "big")

def get_safe_prime(nbit):
    result = 2 * getPrime(nbit // 2) * getPrime(nbit // 2) + 1
    while not isPrime(int(result)):
        result = 2 * getPrime(nbit // 2) * getPrime(nbit // 2) + 1
    return result
```

+ Hàm `get_random` trả lại ta n bytes ngẫu nhiên từ thư viên os
+ Hàm `get_safe_prime` cho ra kết quả làm số nguyên tố có dạng $2 * {prime} * {prime} + 1$

```py
Mat = matrix(Zmod(n), [
    [2, 1] + [get_random(nbit) for _ in range(4)],
    [0, 2] + [get_random(nbit) for _ in range(4)],
    [0, 0] + [4, 1] + [get_random(nbit) for _ in range(2)],
    [0, 0] + [0, 4] + [get_random(nbit) for _ in range(2)],
    [0, 0] + [0, 0] + [8, 1],
    [0, 0] + [0, 0] + [0, 8]
])
```

Đây là phần tạo ra một ma trân với các phần tử trên (so với đường chéo) dược tao ra ngẫu nhiên từ hàm `get_random`, với các phần tử trên đường chéo thì được cố định lại.

```py
p = get_safe_prime(nbit // 2)
q = get_safe_prime(nbit // 2)
n = p*q

C = Mat^FLAG
C = list(C)

```


với n = p * q (q, p là prime) thì ma trận C được mũ flag và trả lại kết quả của ma trận mũ đó.

**Solution:**

Mình cần phải tìm lại ${C_2} = {C_1} ^ {flag} \pmod{n}$, theo như bài trên mình đã nói, những bài giấu đi `n` như thế này thì mình cần đi tìm lại nó trước mới có thể bắt đầu tính.

mình có code thử một chút để tìm xem mã trận trên khi mũ lên thì có kết quả như sau:

```sage
a, b, c, d, e, f, g, h, i, j, k, h = var("a, b, c, d, e, f, g, h, i, j, k, h")

M = matrix([
    [2, 1] + [a, b, c, d],
    [0, 2] + [e, f, g, h],
    [0, 0] + [4, 1] + [i, j],
    [0, 0] + [0, 4] + [k, h],
    [0, 0] + [0, 0] + [8, 1],
    [0, 0] + [0, 0] + [0, 8]
])

print(M ^ 2)
print()
print()
print()
print(M ^ 3)
print()
print()
print()
print(M ^ 4)
print()
print()
print()
print(M ^ 5)
```

Kết quả mình nhần được như sau:

```
[                       4                        4                  6*a + e              a + 6*b + f     a*i + b*k + 10*c + g b*h + a*j + c + 10*d + h]
[                       0                        4                      6*e                  e + 6*f         e*i + f*k + 10*g     f*h + e*j + g + 10*h]
[                       0                        0                       16                        8                 12*i + k             h + i + 12*j]
[                       0                        0                        0                       16                     12*k                 12*h + k]
[                       0                        0                        0                        0                       64                       16]
[                       0                        0                        0                        0                        0                       64]



[                                                                                 8
        12                                                                         28*a + 8*e                                                              10*a + 28*b + e + 8*f                        (6*a + e)*i + 8*a*i + (a + 6*b + f)*k + 8*b*k + 84*c + 12*g (a + 6*b + f)*h + 8*b*h + a*i + (6*a + e)*j + 8*a*j 
+ b*k + 18*c + 84*d + g + 12*h]
[                                                                                 0
         8                                                                               28*e
         10*e + 28*f                                                14*e*i + (e + 6*f)*k + 8*f*k + 84*g                             (e + 6*f)*h + 8*f*h + e*i + 14*e*j + f*k + 18*g + 84*h]
[                                                                                 0
         0                                                                                 64
                  48                                                                       112*i + 16*k
       16*h + 20*i + 112*j + k]
[                                                                                 0
         0                                                                                  0
                  64                                                                              112*k
                  112*h + 20*k]
[                                                                                 0
         0                                                                                  0
                   0                                                                                512
                           192]
[                                                                                 0
         0                                                                                  0
                   0                                                                                  0
                           512]



[                                                                                                                                    16
                                                                                                                32
                                                                                 120*a + 44*e
                                              68*a + 120*b + 12*e + 44*f                                            (6*a + e)*(12*i + k) + 68*a*i + 4*e*i + 
12*(a + 6*b + f)*k + 68*b*k + 4*f*k + 680*c + 108*g (a + 6*b + f)*(12*h + k) + (6*a + e)*(h + i + 12*j) + 68*b*h + 4*f*h + 16*a*i + 68*a*j + 4*e*j + 16*b*k 
+ 228*c + 680*d + 20*g + 108*h]
[                                                                                                                                     0
                                                                                                                16
                                                                                        120*e
                                                            68*e + 120*f                                                                              6*e*(12*i + k) + 68*e*i + 12*(e + 6*f)*k + 68*f*k + 680*g                                          (e + 6*f)*(12*h + k) + 6*e*(h + i + 12*j) + 68*f*h + 16*e*i + 68*e*j + 16*f*k + 228*g + 680*h]
[                                                                                                                                     0
                                                                                                                 0
                                                                                          256
                                                                     256
                                      960*i + 176*k
  176*h + 272*i + 960*j + 24*k]
[                                                                                                                                     0
                                                                                                                 0
                                                                                            0
                                                                     256
                                              960*k
                 960*h + 272*k]
[                                                                                                                                     0
                                                                                                                 0
                                                                                            0
                                                                       0
                                               4096
                          2048]
[                                                                                                                                     0
                                                                                                                 0
                                                                                            0
                                                                       0
                                                  0
                          4096]



[
                                                                                                       32

                                                    80
                                                                                                                                                  496*a + 208*e
                                                                                392*a + 496*b + 92*e + 208*f
                                                              8*(6*a + e)*(12*i + k) + 4*(30*a + 11*e)*i + 544*a*i + 32*e*i + 4*(17*a + 30*b + 3*e + 11*f)*k + 96*(a + 6*b + f)*k + 544*b*k + 32*f*k + 5456*c + 896*g 8*(a + 6*b + f)*(12*h + k) + 8*(6*a + e)*(h + i + 12*j) + 4*(17*a + 30*b + 3*e + 11*f)*h + 544*b*h + 32*f*h + (6*a + e)*(12*i + k) + 196*a*i + 4*e*i + 4*(30*a + 11*e)*j + 544*a*j + 32*e*j + 12*(a + 6*b + f)*k + 196*b*k + 4*f*k + 2504*c + 5456*d + 268*g + 896*h]
[
                                                                                                        0

                                                    32
                                                                                                                                                          496*e
                                                                                               392*e + 496*f
                                                                                                                                    48*e*(12*i + k) + 664*e*i + 4*(17*e + 30*f)*k + 96*(e + 6*f)*k + 544*f*k + 5456*g
      8*(e + 6*f)*(12*h + k) + 48*e*(h + i + 12*j) + 4*(17*e + 30*f)*h + 544*f*h + 6*e*(12*i + k) + 196*e*i + 664*e*j + 12*(e + 6*f)*k + 196*f*k + 2504*g + 
5456*h]
[
                                                                                                        0

                                                     0
                                                                                                                                                           1024
                                                                                                        1280

                                          7936*i + 1664*k
                                                                                                                                  1664*h + 3136*i + 7936*j + 368*k]
[
                                                                                                        0

                                                     0

  0
                                                                                                        1024

                                                   7936*k
                                                                                                                                                   7936*h + 
3136*k]
[
                                                                                                        0

                                                     0                                                                                                      

  0
                                                                                                           0

                                                    32768

 20480]
[
                                                                                                        0

                                                     0

  0
                                                                                                           0

                                                        0

 32768]
```


(Nó hơi khó nhìn sorry)

Nhưng nhìn vào mình thấy khi $C ^ n$ thì các phần tử trên đường chéo chính của nó cũng được mũ n tức

```py


	    [2 ^ n, 1, ., ., ., .],
	    [0, 2 ^ n, ., ., ., .],
C ^ n =	    [0, 0, 4 ^ n, 1, ., .],
	    [0, 0, 0, 4 ^ n, ., .],
	    [0, 0, 0, 0, 8 ^ n, 1],
	    [0, 0, 0, 0, 0, 8 ^ n]

```

khi đó c[0][0] = $2 ^ {n}$, c[2][2] = $4 ^ {n}$ và c[4][4] = $8 ^ {n}$ nhưng đây là các phép tính trong trường mod n nên ta có:

+ $a = 2 ^ {n} \pmod{n}$ 
+ $b = 4 ^ {n} \pmod{n}$
+ $c = 8 ^ {n} \pmod{n}$

Sau đó mình biến đổi như sau:

+ $a = 2 ^ {n} \pmod{n}$ 
+ $b = 4 ^ {n} = 2 ^ {2 * n} = {2 ^ n} ^ 2 = a ^ 2\pmod{n}$
+ $c = 8 ^ {n} = 2 ^ {3 * n} = {2 ^ n} ^ 3 = a ^ 3\pmod{n}$

$$b = a ^ 2 \pmod{n} \to a ^ 2 - b = q * n$$

$$c = a ^ 3 \pmod{n} \to a ^ 3 - c = p * n$$

$\to {gcd}(a ^ 2 - b, a ^ 3 - c) = n$ 

Ngoài ra mình thấy:

+ với n = 2; ${c ^ 2}[0][1] = 4 = 2 * 2$
+ với n = 3; ${c ^ 3}[0][1] = 12 = 2 ^ 2 * 3$
+ với n = 4; ${c ^ 4}[0][1] = 32 = 2 ^ 3 * 4$

+ với n; ${c ^ n}[0][1] = {2 ^ {n - 1}} * n$

nên $k = {c ^ {flag}}[0][1] = {2 ^ {{flag} - 1}} * {flag} \to 2 * k = {2 ^ {flag}} * {flag} = a * {flag} \to {flag} = ^ {2 * k} / _ {a}$

Từ đó mình có thể tính lại flag.

**Code:**

```sage
from tqdm import *
C = [(34285747519707996626385667339662460790207453899564234933279840884637317470277963204844978855648863282661822817842406467276103235437115285776600339324582650206354227684286926765912841373720037206104315460984467834472878792871363724319500026730744559032592830317957861116684230815080884748210510265257121727411, 82389813574193236731268728055226346949935905889688170425892513962291738546070054175286986817742962125712704451033935523159914920684418980229184675189392660990212113237529057511102468180315624316711603102279872782413287481544411903032504611191117588506754985276936284421146109462510942343677179125102460355334, 127247078267314356402767966557448505733207679608121587776826570427528349536126399258128998506925096202352385266899982179247602157054605592001529350471426605916092686761690699179270970709575073044160148478140835495982904453410049961250136921488023338211130908836050232268149658252094451825981649386429967157023, 110997696050305177374684801376195205614043414698289134283464488914579055650336577562089998807469786126102628845652757901772021003891120075086100794690060492018372114798499796476503564426511552576093110306562634265833200794380828146503816203682087385703698944330589010185628240036153869595329794474678963954269, 95429943964904023259514531987953637596024020044100694025548029082876352647190904910373013883591092911247251504859346180249828148105405110896981416324094823746473360350150849817138654025822760100976625537661710179191573475427725481576122332324895773326199055069720422096583714906980119788052757109463536989130, 76925650644921944564121660415039326382672571942134701742579804900375156897677412516140878223663671839157682242947665571676520752706843330108967323669457404588586535061237444710279897627741144122937187393054928934936687732687921193790751566393662886825169077208127284176632544803227991370949818150005932210304), (0, 34285747519707996626385667339662460790207453899564234933279840884637317470277963204844978855648863282661822817842406467276103235437115285776600339324582650206354227684286926765912841373720037206104315460984467834472878792871363724319500026730744559032592830317957861116684230815080884748210510265257121727411, 85967636444726554256032386847538080607273641997139556709873191645024773479482183751659433639594934875197169824518560503372716992088412826701271790577397701838066670897181757432783438839115526851698428389903365201752735197054876789440370911041505435306549154757322168278884403206082946661059841799276902279607, 110321848943899292929831522195898953167052692821484311182642200713072229078674653831094653900345561159369211814825383018259327689455180388330932020089176571654576145870074563603252413779245365342554600824303390696086590372070050354595330074227342114164575397697848706436203854215556384244963529017935602600689, 55321436108075224950728586469455754360500596962017688262306497027259209074949803121055336152763619653715618911652213266949708309957674991371935559144633368828172207173145372615220450607178667764319048810554905786212377479905241378131059006116348325599909367174854478256625377537634718283487921887388679931300, 121048214328487578063535470984430739166205977393814304445813791572773220134359940700786671669567539273399625221907347167959074671295760177948556479010579225978917918535032412717072730223986401267581116138177971941402742413385270319230751393845616816965070450211819298226894334399356881715479006792296977303116), (0, 0, 80891788386112939497749276978496951092908047537517752191112348346041605282820278415204830919700840360371114407873821260986140627885494462923855784343766007471406691139724032186081486065167152331309928933439563087594932165713814698240940689654799590764311096627705559355661741126880749623083953480524440103996, 98127807327139994371479310755482264253499077621954160265776803909962087269443207623777017430975688540885576031084499718360878131623357206459366594111595569751254398053416214104147757969318816248746123610412479211529236153906708864168414330919431944363564172025204269508207805032491500543298879609362168155698, 65511482182385099252523608525317643713139065614405324455763784441479732896196144143630212812577305057210145612770975280343168022555945650814573970996890826522557999047275529322348420693034478105886809355222570889445527587635177667364042090723912339748512431185136779345494523747668733698804934976215893958288, 47395420931311533463576620820998773093140094423967370338777509171164699213419123512474441784558146041667540557107610725716163070022770572094504815720978368593469076026134774205916872923158523446883115622548066715665889163816586554653727221255672945695748970848307935789400330008330191289067490505817853508862), (0, 0, 0, 80891788386112939497749276978496951092908047537517752191112348346041605282820278415204830919700840360371114407873821260986140627885494462923855784343766007471406691139724032186081486065167152331309928933439563087594932165713814698240940689654799590764311096627705559355661741126880749623083953480524440103996, 19698820472058378412126192842030797220400882933373012220982539297272840493833295012123104281630408975161684583174403520414441877705582176563034772573895923595952612217426667572338807473485060098014543992573292667351072747962727283791740574278403611513201362656878372277715791010274896917611983518661952140153, 123510953871821884312855093053364645536177520009689630246292371010124299893864894909800725518340823661094473516585146142340021906280407678497822070318952778328284650261834023459467329786786889648844029738405121401290299843929018994002831246816483309594538299064894303565350991068375984784398159294612728278815), (0, 0, 0, 0, 36580210170460317737762146444885635769591964296289890711389087000847139534806165797517572963756420701630101713343229692997790887039708011239887899158602488099058023454307392387825436996066794401349180417178870019892425641929320878895403740655587101563655595067050855919740156100994268635382369423383067032821, 39071393947194921035771816301731926515001496696996162605545586710593160202215733075781810261530483080161843001707288615255381706789857593381598670763208249387924275996361728526530257131514765795139507343167639937751870811497537961210868263876827751668386006289349446841212411861730197725192485058916383785937), (0, 0, 0, 0, 0, 36580210170460317737762146444885635769591964296289890711389087000847139534806165797517572963756420701630101713343229692997790887039708011239887899158602488099058023454307392387825436996066794401349180417178870019892425641929320878895403740655587101563655595067050855919740156100994268635382369423383067032821)]

n = gcd(C[2][2] - C[0][0] ^ 2, C[4][4] - C[0][0] ^ 3)
n //= 5

Z = Zmod(n)
a = Z(C[0][0])
b = Z(C[0][1])
print(bytes.fromhex(hex(b * pow(a * pow(2, -1, n), -1, n))[2:]))

```
