

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4004 = Integer(4004); _sage_const_216 = Integer(216); _sage_const_137 = Integer(137); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_16 = Integer(16); _sage_const_6 = Integer(6)# import public_values_aux
# from public_values_aux import *

# load('castryck_decru_shortcut.sage')
# load('sandwich_attack.sage')

# SIKE_parameters = {
#     "SIKEp434" : (216, 137),
#     "SIKEp503" : (250, 159),
#     "SIKEp610" : (305, 192),
#     "SIKEp751" : (372, 239),
#     "SIKEp964" : (486, 301), # removed after NIST round 1
# }

# # Change me to attack different parameter sets
# NIST_submission = "SIKEp434"
# a, b = SIKE_parameters[NIST_submission]

# print(f"Running the attack against {NIST_submission} parameters, which has a prime: 2^{a}*3^{b} - 1")

# print(f"Generating public data for the attack...")
# # Set the prime, finite fields and starting curve
# # with known endomorphism
# p = 2^a*3^b - 1
# public_values_aux.p = p
# Fp2.<i> = GF(p^2, modulus=x^2+1)
# R.<x> = PolynomialRing(Fp2)

# E_start = EllipticCurve(Fp2, [0,6,0,1,0])
# E_start.set_order((p+1)^2, num_checks=0) # Speeds things up in Sage

# # Generation of the endomorphism 2i
# two_i = generate_distortion_map(E_start)

import os
os.environ["TERM"] = "xterm-256color"
from pwn import *
from Crypto.Cipher import AES

# io = process(["sage", "chall.sage"])
io = remote("13.233.255.238", _sage_const_4004 )
io.interactive()
e2, e3 = _sage_const_216 , _sage_const_137 
p = _sage_const_2 **e2 * _sage_const_3 **e3 - _sage_const_1 
F = GF(p**_sage_const_2 , modulus=[_sage_const_1 ,_sage_const_0 ,_sage_const_1 ], name = "i")
i = F.gen()

def generate_torsion_basis(E, l, e, cofactor):
    while True:
        P = cofactor * E.random_point()
        if (l**(e-_sage_const_1 )) * P != _sage_const_0 : 
            break
    while True:
        Q = cofactor * E.random_point()
        if (l**(e-_sage_const_1 )) * Q != _sage_const_0  and P.weil_pairing(Q, l**e) != _sage_const_1 :
            break
    return P, Q

def comp_iso(E, Ss, l, e):
    φ,  E1 = None, E
    for k in range(e):
        R = [l**(e-k-_sage_const_1 ) * S for S in Ss]
        ϕk = E1.isogeny(kernel=R)
        Ss = [ϕk(S) for S in Ss]
        E1 = ϕk.codomain()
        φ  = ϕk if φ is None else ϕk * φ
    return φ, E1

def j_ex(E, sk, pk, l, e):
    φ, _ = comp_iso(E, [pk[_sage_const_0 ] + sk*pk[_sage_const_1 ]], l, e)
    return φ.codomain().j_invariant()

def decrypt_flag(iv :str, ct: str, ss: bytes):
    iv = bytes.fromhex(iv)
    ct = bytes.fromhex(ct)
    key = hashlib.sha256(ss).digest()[:_sage_const_16 ]
    c  = AES.new(key, AES.MODE_CBC, iv)
    return c.decrypt(ct)

io.recvuntil(b"PA: ")
PA = eval(io.recvline())
io.recvuntil(b"QA: ")
QA = eval(io.recvline())
io.recvuntil(b"PB: ")
PB = eval(io.recvline())
io.recvuntil(b"QB: ")
QB = eval(io.recvline())
io.recvuntil(b"EA invariants: ")
EA_invariants = eval(io.recvline())
io.recvuntil(b"APB: ")
φAPB = eval(io.recvline())
io.recvuntil(b"AQB: ")
φAQB = eval(io.recvline())
io.recvuntil(b"APA: ")
φAPA = eval(io.recvline())
io.recvuntil(b"AQA: ")
φAQA = eval(io.recvline())
io.recvuntil(b"EB invariants: ")
EB_invariants = eval(io.recvline())
io.recvuntil(b"BPA: ")
φBPA = eval(io.recvline())
io.recvuntil(b"BQA: ")
φBQA = eval(io.recvline())

io.recvuntil(b"IV1: ")
iv1 = str(io.recvline()).replace("b'", "")[:-_sage_const_3 ]
io.recvuntil(b"CT1: ")
ct1 = str(io.recvline()).replace("b'", "")[:-_sage_const_3 ]
io.recvuntil(b"IV2: ")
iv2 = str(io.recvline()).replace("b'", "")[:-_sage_const_3 ]
io.recvuntil(b"CT2: ")
ct2 = str(io.recvline()).replace("b'", "")[:-_sage_const_3 ]
print(f"{iv1 = }")
print(f"{ct1 = }")
print(f"{iv2 = }")
print(f"{ct2 = }")

E0 = EllipticCurve(F, [_sage_const_0 ,_sage_const_6 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ])
EA = EllipticCurve(F, EA_invariants)
EB = EllipticCurve(F, EB_invariants)

PA = E0(PA)
PB = E0(PB)
QA = E0(QA)
QB = E0(QB)

φAPB = EA(φAPB)
φAQB = EA(φAQB)
φAPA = EA(φAPA)
φAQA = EA(φAQA)

φBPA = EB(φBPA)
φBQA = EB(φBQA)

kA = discrete_log(-φAPA, φAQA, operation = "+")
j1 = j_ex(E0, kA, (PB,QB), _sage_const_3 , e3)
print(decrypt_flag(iv1, ct1, str(j1).encode()))

