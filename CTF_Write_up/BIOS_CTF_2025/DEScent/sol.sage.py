

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_60 = Integer(60); _sage_const_128 = Integer(128); _sage_const_16 = Integer(16); _sage_const_15 = Integer(15); _sage_const_2 = Integer(2)#!/usr/bin/env sage
import os, json
from hashlib import md5
from Crypto.Cipher import DES
os.environ["TERM"] = "linux"
from pwn import *
from Crypto.Util.number import *

context.log_level = "debug"
def matrix_overview(BB):
    for ii in range(BB.dimensions()[_sage_const_0 ]):
        a = ('%02d ' % ii)
        for jj in range(BB.dimensions()[_sage_const_1 ]):
            if BB[ii, jj] == _sage_const_0 :
                a += ' '
            else:
                a += 'X'
            if BB.dimensions()[_sage_const_0 ] < _sage_const_60 :
                a += ' '
        print(a)
        
P = ComplexField(_sage_const_128 )

F = PolynomialRing(ZZ, 'x', _sage_const_16 )
xs = list(F.gens())

def encode(data):
    P = ComplexField(_sage_const_128 )['x']; (x,) = P._first_ngens(1)
    poly = _sage_const_0 
    for i in range(len(data)):
        poly += data[i] * x ** i
    print(poly)
    return poly.roots()[_sage_const_1 ][_sage_const_0 ]

s = process(['sage', 'chal.sage'])

s.sendline(json.dumps({"option": "get_secret"}))

output1 = eval(s.recvline().decode())

def gen_rand(user_seed, server_seed):
    return DES.new(user_seed + server_seed, DES.MODE_ECB).encrypt(b"\x00" * _sage_const_16 )

def xor(data, key):
    from itertools import cycle
    if len(key) > len(data):
        key = data, data = key
    cycled_key = cycle(key)
    return bytes([b ^ next(cycled_key) for b in data])


# print(gen_rand(b'\x00' * 4, b'\x00' * 4))
# print(gen_rand(b'\x01' + b'\x00' * 3, b'\x00' * 4))
i = P(output1['encoded_secret'])
print(output1["user_seed"])
key = xor(bytes.fromhex(output1["user_seed"]), b"\x01")

s.sendline(json.dumps({"option": "encode", "data": '01' * _sage_const_15  + '00', "user_seed": (key).hex()}))

output2 = eval(s.recvline().decode())

i -= P(output2["encoded_data"]) - encode(bytes.fromhex('01' * _sage_const_15  + '00'))


def encode2(i):
    poly = sum(xs[k] * (i) ** k for k in range(_sage_const_16 ))
    return poly

eqs = []
eq1, eq2 = [], []
ss = [var('s' + str(i)) for i in range(_sage_const_16 )]
for i, _ in enumerate((encode2(i)).coefficients()):
    eq1.append((QQ(_.real_part()) ))
    eq2.append((QQ(_.imag_part()) ))
eqs.append(eq1)
eqs.append(eq2)

M = diagonal_matrix([_sage_const_1 /(_sage_const_1  << _sage_const_128 )] * _sage_const_16 )
M = block_matrix(QQ,
    [
        [matrix(eqs).T, M]
     ]
)

M = M.LLL()
M *= (_sage_const_1  << _sage_const_128 )

k = (bytes(list(M[_sage_const_0 ][_sage_const_2 :] * sign(M[_sage_const_0 ][-_sage_const_1 ]))))
s.sendline(json.dumps({"option": "verify", "user_secret": k.hex()}))
s.interactive()

